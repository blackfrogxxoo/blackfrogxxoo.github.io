<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="blackfrog的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="blackfrog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="blackfrog">
<meta property="og:description" content="blackfrog的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="blackfrog">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>blackfrog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">blackfrog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">慎 敬 勤 恒</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">blackfrog</p>
  <div class="site-description" itemprop="description">blackfrog的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/04/first/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="blackfrog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blackfrog">
      <meta itemprop="description" content="blackfrog的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | blackfrog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/04/first/" class="post-title-link" itemprop="url">拒绝代码PUA，优雅地迭代业务代码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-04 12:12:57" itemprop="dateCreated datePublished" datetime="2023-09-04T12:12:57+08:00">2023-09-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-06 17:51:14" itemprop="dateModified" datetime="2023-09-06T17:51:14+08:00">2023-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%87%8D%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">重构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer" />

<h2 id="最初的美好"><a href="#最初的美好" class="headerlink" title="最初的美好"></a>最初的美好</h2><p>没有历史包袱，就没有压力，就是美好的。</p>
<p>假设项目启动了这样一个业务——造车：生产一辆小汽车(<code>Car</code>)，分别在不同的零件车间（车架（<code>Sheel</code>）、发动机（<code>Engine</code>）、车轮（<code>Wheel</code>））安装相应的零件，所有零件安装完成后回到提车车间就可以提车。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c902c7bfa03c40d7b2efd8ee5cd4a9bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=270&h=600&s=496136&e=gif&f=136&b=fcf7fc" alt="image"></p>
<p>这样的需求开发起来很简单：</p>
<ul>
<li><p>数据实体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">data class Car(</span><br><span class="line">    var shell: Shell? = null,</span><br><span class="line">    var engine: Engine? = null,</span><br><span class="line">    var wheel: Wheel? = null,</span><br><span class="line">) : Serializable &#123;</span><br><span class="line">    override fun toString(): String &#123;</span><br><span class="line">        return &quot;Car: Shell($&#123;shell&#125;), Engine($&#123;engine&#125;), Wheel($&#123;wheel&#125;)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data class Shell(</span><br><span class="line">    ...</span><br><span class="line">) : Serializable</span><br><span class="line"></span><br><span class="line">data class Engine(</span><br><span class="line">    ...</span><br><span class="line">) : Serializable</span><br><span class="line"></span><br><span class="line">data class Wheel(</span><br><span class="line">    ...</span><br><span class="line">) : Serializable</span><br></pre></td></tr></table></figure>
</li>
<li><p>零件车间（以车架为例）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class ShellFactoryActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var btn: Button</span><br><span class="line">    private lateinit var back: Button</span><br><span class="line">    private lateinit var status: TextView</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_shell_factory)</span><br><span class="line">        val car = intent.getSerializableExtra(&quot;car&quot;) as Car</span><br><span class="line">        status = findViewById(R.id.status)</span><br><span class="line">        btn = findViewById(R.id.btn)</span><br><span class="line">        btn.setOnClickListener &#123;</span><br><span class="line">            car.shell = Shell(</span><br><span class="line">                id = 1,</span><br><span class="line">                name = &quot;比亚迪车架&quot;,</span><br><span class="line">                type = 1</span><br><span class="line">            )</span><br><span class="line">            status.text = car.toString()</span><br><span class="line">        &#125;</span><br><span class="line">        back = findViewById(R.id.back)</span><br><span class="line">        back.setOnClickListener &#123;</span><br><span class="line">            setResult(RESULT_OK, intent.apply &#123;</span><br><span class="line">                putExtra(&quot;car&quot;, car)</span><br><span class="line">            &#125;)</span><br><span class="line">            finish()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class EngineFactoryActivity : AppCompatActivity() &#123;</span><br><span class="line">    // 和安装车架流程一样</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WheelFactoryActivity : AppCompatActivity() &#123;</span><br><span class="line">    // 和安装车架流程一样</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提车车间</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> car: Car? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        car = Car()</span><br><span class="line">        refreshStatus()</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.shell).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> it = Intent(<span class="keyword">this</span>, ShellFactoryActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            it.putExtra(<span class="string">&quot;car&quot;</span>, car)</span><br><span class="line">            startActivityForResult(it, REQUEST_SHELL)</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.engine).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> it = Intent(<span class="keyword">this</span>, EngineFactoryActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            it.putExtra(<span class="string">&quot;car&quot;</span>, car)</span><br><span class="line">            startActivityForResult(it, REQUEST_ENGINE)</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.wheel).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> it = Intent(<span class="keyword">this</span>, WheelFactoryActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            it.putExtra(<span class="string">&quot;car&quot;</span>, car)</span><br><span class="line">            startActivityForResult(it, REQUEST_WHEEL)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">if</span> (resultCode != RESULT_OK) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">            REQUEST_SHELL -&gt; &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;安装车架完成&quot;</span>)</span><br><span class="line">                car = <span class="keyword">data</span>?.getSerializableExtra(<span class="string">&quot;car&quot;</span>) <span class="keyword">as</span> Car</span><br><span class="line">            &#125;</span><br><span class="line">            REQUEST_ENGINE -&gt; &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;安装发动机完成&quot;</span>)</span><br><span class="line">                car = <span class="keyword">data</span>?.getSerializableExtra(<span class="string">&quot;car&quot;</span>) <span class="keyword">as</span> Car</span><br><span class="line">            &#125;</span><br><span class="line">            REQUEST_WHEEL -&gt; &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;安装车轮完成&quot;</span>)</span><br><span class="line">                car = <span class="keyword">data</span>?.getSerializableExtra(<span class="string">&quot;car&quot;</span>) <span class="keyword">as</span> Car</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        refreshStatus()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">refreshStatus</span><span class="params">()</span></span> &#123;</span><br><span class="line">        findViewById&lt;TextView&gt;(R.id.status).text = car?.toString()</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.save).run &#123;</span><br><span class="line">            isEnabled = car?.shell != <span class="literal">null</span> &amp;&amp; car?.engine != <span class="literal">null</span> &amp;&amp; car?.wheel != <span class="literal">null</span></span><br><span class="line">            setOnClickListener &#123;</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, <span class="string">&quot;提车咯！&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_SHELL = <span class="number">1</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_ENGINE = <span class="number">2</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_WHEEL = <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>即使是初学者也能看出来，业务实现起来很简单，通过<code>Activity</code>的<code>startActivityForResult</code>就能跳转到相应的零件车间，安装好零件回到提车车间就完事了。</p>
<h2 id="开始迭代"><a href="#开始迭代" class="headerlink" title="开始迭代"></a>开始迭代</h2><p>往往业务的第一个版本就是这么简单，感觉也没什么好重构的。</p>
<p>但是业务难免会进行迭代。比如业务迭代到1.1版本：客户想要给汽车装上行车电脑，而安装行车电脑不需要跳转到另一个车间，而是在提车车间操作，但是需要很长的时间。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0051cf92f0c44acb8ade924b7d9b253~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=270&h=600&s=606740&e=gif&f=260&b=fbf7fc" alt="image"></p>
<p>看起来也简单，新增一个<code>Computer</code>实体类和<code>ComputerFactoryHelper</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">object ComputerFactoryHelper &#123;</span><br><span class="line">    fun provideComputer(block: Computer.() -&gt; Unit) &#123;</span><br><span class="line">        Thread.sleep(5_000)</span><br><span class="line">        block(Computer())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data class Computer(</span><br><span class="line">    val id: Int = 1,</span><br><span class="line">    val name: String = &quot;行车电脑&quot;,</span><br><span class="line">    val cpu: String = &quot;麒麟90000&quot;</span><br><span class="line">) : Serializable &#123;</span><br><span class="line">    override fun toString(): String &#123;</span><br><span class="line">        return &quot;$name-$cpu&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再在提车车间新增按钮和逻辑代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">findViewById&lt;Button&gt;(R.id.computer).setOnClickListener &#123;</span><br><span class="line">    object : Thread() &#123;</span><br><span class="line">        override fun run() &#123;</span><br><span class="line">            ComputerFactoryHelper.provideComputer &#123;</span><br><span class="line">                car?.computer = this</span><br><span class="line">                runOnUiThread &#123; refreshStatus() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前看起来也没啥难的，那是因为我们模拟的业务场景足够简单，但是相信很多实际项目的屎山代码，就是通过这样的业务迭代，一点一点地堆积而成的。</p>
<h2 id="从迭代到崩溃"><a href="#从迭代到崩溃" class="headerlink" title="从迭代到崩溃"></a>从迭代到崩溃</h2><p>咱们来采访一下最近被一个小小的业务迭代需求搞崩溃的Android开发——小王。</p>
<blockquote>
<p>记者：小王你好，听说最近你Emo了，甚至多次萌生了就地辞职的念头？</p>
<p>小王：最近AI不是很火吗，产品给我提了一个需求，在上传音乐时可以选择在后端生成一个AI视频，然后一起上传。</p>
<p>记者：哦？这不是一个小需求吗？</p>
<p>小王：但是我打开目前上传业务的代码就傻了啊！就说Activity吧，有：BasePublishActivity，BasePublishFinallyActivity，SinglePublishMusicActivity，MultiPublishMusicActivity，PublishFinallyActivity，PublishCutMusicFinallyActivity， Publish(好多好多)FinallyActivity… 当然，这只是冰山一角。再说上传流程。如果只上传一首音乐，需要先调一个接口<code>/sts</code>拿到一个Oss Token，再调用第三方的Oss库上传文件，拿到一个url，然后再把这个url和其他的信息（标题、标签等）组成一个HashMap，再调用一个接口<code>/save</code>提交到后端，相当于调3个接口… 如果要批量上传N个音乐，就要调3 * N个接口，如果还要给每个音乐配M个图片，就要调3 * N+3 * N * M个接口… 如果上传一个音乐配一个本地视频，就要调3 * 2 * N个接口，并且，上传视频流程还不一样的是，需要在调用<code>/save</code>接口之后再调用第三方Oss上传视频文件…再说数据类。上面提到上传过程中需要添加图片、视频、活动类型啥的，代码里封装了一个EditInfo类足足有30个属性！，由于是Java代码并且实现了<code>Parcelable</code>接口，光一个Data类就有400多行！你以为这就完了？EditInfo需要在上传时转成PublishInfo类，PublishInfo还可以转成PublishDraft，PublishDraft可以保存到数据库中，从数据库中可以读取PublishDraft然后转成EditInfo再重新编辑…</p>
<p>记者：（感觉小王精神状态有点问题，于是掐掉了直播画面）</p>
</blockquote>
<p>相信小王的这种情况，很多业务开发同学都经历过吧。回头再看一下前面的造车业务，其实和小王的上传业务一样，就是一开始很简单，迭代个7、8个版本就开始陷入一种困境：即使迭代需求再小，开发起来都很困难。</p>
<h2 id="优雅地迭代业务代码？"><a href="#优雅地迭代业务代码？" class="headerlink" title="优雅地迭代业务代码？"></a>优雅地迭代业务代码？</h2><p>假如咱们想要优雅地迭代业务代码，应该怎么做呢？</p>
<p>小王遇到的这座屎山，咱们现在就不要去碰了，先就从前面提到的造车业务开始吧。</p>
<p>很多同学会想到<strong>重构</strong>，俺也一样。接下来，我就要讨论一下如何<strong>优雅</strong>而<strong>安全</strong>地重构既有业务代码。</p>
<blockquote>
<p>先抛出一个观点：<strong>对于程序员来说，想要保持“优雅”，最重要的品质就是抽象。</strong></p>
</blockquote>
<p>❓ 这时可能有同学就要反驳我了：过早的抽象没有必要。</p>
<p>❗ 别急，我现在要说的抽象，并不是<strong>代码层面的抽象</strong>，而是对<strong>业务的抽象</strong>，乃至对<strong>技术思维的抽象</strong>。</p>
<p>什么是<strong>代码层面的抽象</strong>？比如刚刚的<code>Shell/Engine/WheelFactoryActivity</code>，其实是可以抽象为<code>BaseFactoryActivity</code>，然后通过实现其中的零件类型就行了。但我不会建议你这么做，为啥？看看小王刚才的疯言疯语就明白了。各个<code>XxxFactoryActivity</code>看着差不多，但在实际项目中很可能会开枝散叶，各自迭代出不同的业务细节。到那时，项目里就是各种<code>BaseXxxActivity</code>，<code>XxxV1Activity</code>，<code>XxxV2Activity</code>…</p>
<p>那什么又是<strong>业务的抽象</strong>？直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface CarFactory &#123;</span><br><span class="line">    val factory: suspend Car.() -&gt; Car</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>造车业务，无论在哪个环节，都是在<code>Car</code>上装配零件（或者任何出其不意的操作），然后产生一个新的<code>Car</code>；另外，这个环节无论是跳转到零件车间安装零件，还是在提车车间里安装行车电脑，都是耗时操作，所以需要加<code>suspend</code>关键词。</p>
<p>❓ 这时可能有同学说：害！你这和<code>BaseFactoryActivity</code>有啥区别，不就是把抽象类换成接口了吗？</p>
<p>❗ 别急，我并没有要让<code>XxxFactoryActivity</code>去继承<code>CarFactory</code>啊，想想小王吧，这个<code>XxxFactoryActivity</code>就相当于他的同事在两年前写的代码，小王肯定打死都不会想去修改这里面的代码的。</p>
<p><code>Computer</code>是新业务，我们只改它。首先我们根据这个接口把<code>ComputerFactoryHelper</code>改一下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ComputerFactoryHelper : CarFactory &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">provideComputer</span><span class="params">(block: <span class="type">Computer</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        delay(<span class="number">5_000</span>)</span><br><span class="line">        block(Computer())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> factory: <span class="keyword">suspend</span> Car.() -&gt; Car = &#123;</span><br><span class="line">        provideComputer &#123;</span><br><span class="line">            computer = <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，在提车车间就可以这样改：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> computerFactory: CarFactory = ComputerFactoryHelper</span><br><span class="line">findViewById&lt;Button&gt;(R.id.computer).setOnClickListener &#123;</span><br><span class="line">    lifecycleScope.launchWhenResumed &#123;</span><br><span class="line">        computerFactory.factory.invoke(car)</span><br><span class="line">        refreshStatus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>❓ 那么<code>XxxFactoryActivity</code>相关的流程又应该怎么重构呢？</p>
<h2 id="Emo时间"><a href="#Emo时间" class="headerlink" title="Emo时间"></a>Emo时间</h2><p>我先反问一下大家，为啥咱们Android程序员总是盯着<code>Activity</code>不放呢？</p>
<p>我再反问一下大家，为啥咱们Android程序员总是盯着<code>Activity</code>不放呢？</p>
<p>我再再反问一下大家，为啥咱们Android程序员总是盯着<code>Activity</code>不放呢？</p>
<p>甚至，很多人即使学了<code>Compose</code>和<code>Flutter</code>，仍然对<code>Activity</code>心心念念。</p>
<blockquote>
<p>当你在一千个日日夜夜里，重复地写着<code>XxxActivity</code>，写<code>onCreate/onResume/onDestroy</code>，写<code>startActivityForResult/onActivityResult</code>时，当你每次想要换工作，打开面经背诵<code>Activity</code>的启动模式，生命周期，<code>AMS</code>原理时，可曾对<code>Activity</code>有过厌倦，可曾思考过编程的意义？</p>
<p>你也曾努力查阅<code>Activity</code>的源码，学习<code>MVP</code>&#x2F;<code>MVVM</code>&#x2F;<code>MVI</code>架构，试图让你的<code>Activity</code>保持清洁，但无论你怎么努力，却始终活在<code>Activity</code>的阴影之下。</p>
<p>你有没有想过，咱们正在被<code>Activity</code> <strong>PUA</strong>？</p>
</blockquote>
<p>说实话，作为一名INFP，本人不是很适合做程序员。相比技术栈的丰富和技术原理的深入，我更看重的是写代码的感受。如果写代码都能被PUA，那我还怎么愉快的写代码？</p>
<p>当我Emo了很久之后，我意识到了，我一直在被代码PUA，不光是同事的代码，也有自己的代码，甚至有Android框架，以及外国大佬不断推出的各种新技术新框架。</p>
<blockquote>
<p>对对对！你们都没有问题，是我太菜了555555555</p>
</blockquote>
<h2 id="优雅转身"><a href="#优雅转身" class="headerlink" title="优雅转身"></a>优雅转身</h2><p>Emo过后，还是得回到残酷的职场啊！但是我们要优雅地转身回来！</p>
<p>❓ 刚才不是说要处理<code>XxxFactoryActivity</code>相关业务吗？</p>
<p>❗ 这时我就要提到另外一种抽象：<strong>技术思维的抽象</strong>！</p>
<p>Activity？F*ck off！</p>
<p><code>Activity</code>的跳转返回啥的，也无非就是一次耗时操作嘛，咱们也应该将它抽象为<code>CarFactory</code>，就是这个东东:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface CarFactory &#123;</span><br><span class="line">    val factory: suspend Car.() -&gt; Car</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于这个信念，我从记忆中想到这么一个东东：<code>ActivityResultLauncher</code>。</p>
<p>说实话，我以前都没用过这玩意儿，但是我这时好像抓到了救命稻草。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/C_biubiubiu/article/details/123296728">随便搜了个教程并谢谢他</a>，参考这篇博客，我们可以把<code>startActivityForResult</code>和<code>onActivityResult</code>这套流程，封装成一次异步调用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> startActivityForResultLauncher: StartActivityForResultLauncher</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        startActivityForResultLauncher = StartActivityForResultLauncher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startActivityForResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        intent: <span class="type">Intent</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        callback: (<span class="type">resultCode</span>: <span class="type">Int</span>, <span class="type">data</span>: <span class="type">Intent</span>?) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        startActivityForResultLauncher.launch(intent) &#123;</span><br><span class="line">            callback.invoke(it.resultCode, it.<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让<code>MainActivity</code>继承<code>BaseActivity</code>，就可以绕过<code>Activity</code>了，后面的事情就简单了。只要咱们了解过协程，就能轻易想到异步转同步这一普通操作：<code>suspendCoroutine</code>。</p>
<p>于是，我们就可以在不修改<code>XxxFactoryActivity</code>的情况下，写出基于<code>CarFactory</code>的代码了。还是以车架车间为例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShellFactoryHelper</span>(<span class="keyword">private</span> <span class="keyword">val</span> activity: BaseActivity) : CarFactory &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> factory: <span class="keyword">suspend</span> Car.() -&gt; Car = &#123;</span><br><span class="line">        suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">            <span class="keyword">val</span> it = Intent(activity, ShellFactoryActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            it.putExtra(<span class="string">&quot;car&quot;</span>, <span class="keyword">this</span>)</span><br><span class="line">            activity.startActivityForResult(it) &#123; resultCode, <span class="keyword">data</span> -&gt;</span><br><span class="line">                (<span class="keyword">data</span>?.getSerializableExtra(<span class="string">&quot;car&quot;</span>) <span class="keyword">as</span>? Car)?.let &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;安装车壳完成&quot;</span>)</span><br><span class="line">                    shell = it.shell</span><br><span class="line">                    continuation.resumeWith(Result.success(<span class="keyword">this</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在提车车间，和<code>Computer</code>业务同样的使用方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> shellFactory: CarFactory = ShellFactoryHelper(<span class="keyword">this</span>)</span><br><span class="line">findViewById&lt;Button&gt;(R.id.shell).setOnClickListener &#123;</span><br><span class="line">    lifecycleScope.launchWhenResumed &#123;</span><br><span class="line">        shellFactory.factory.invoke(car)</span><br><span class="line">        refreshStatus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，在我们的提车车间，依赖的就是一些<code>CarFactory</code>，所有的业务操作都是抽象的。到达这个阶段，相信大家都有了自己的一些想法了（比如维护一个<code>carFactoryList</code>，用<code>Hilt</code>管理<code>CarFactory</code>依赖，泛型封装等），想要继续怎么重构&#x2F;维护，就全看自己的实际情况了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : BaseActivity() &#123;</span><br><span class="line">    private var car: Car = Car()</span><br><span class="line">    private var computerFactory: CarFactory = ComputerFactoryHelper</span><br><span class="line">    private var engineFactory: CarFactory = EngineFactoryHelper(this)</span><br><span class="line">    private var shellFactory: CarFactory = ShellFactoryHelper(this)</span><br><span class="line">    private var wheelFactory: CarFactory = WheelFactoryHelper(this)</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        refreshStatus()</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.shell).setOnClickListener &#123;</span><br><span class="line">            lifecycleScope.launchWhenResumed &#123;</span><br><span class="line">                shellFactory.factory.invoke(car)</span><br><span class="line">                refreshStatus()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.engine).setOnClickListener &#123;</span><br><span class="line">            lifecycleScope.launchWhenResumed &#123;</span><br><span class="line">                engineFactory.factory.invoke(car)</span><br><span class="line">                refreshStatus()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.wheel).setOnClickListener &#123;</span><br><span class="line">            lifecycleScope.launchWhenResumed &#123;</span><br><span class="line">                wheelFactory.factory.invoke(car)</span><br><span class="line">                refreshStatus()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.computer).setOnClickListener &#123;</span><br><span class="line">            lifecycleScope.launchWhenResumed &#123;</span><br><span class="line">                Toast.makeText(this@MainActivity, &quot;稍等一会儿&quot;, Toast.LENGTH_LONG).show()</span><br><span class="line">                computerFactory.factory.invoke(car)</span><br><span class="line">                Toast.makeText(this@MainActivity, &quot;装好了！&quot;, Toast.LENGTH_LONG).show()</span><br><span class="line">                refreshStatus()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun refreshStatus() &#123;</span><br><span class="line">        findViewById&lt;TextView&gt;(R.id.status).text = car.toString()</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.save).run &#123;</span><br><span class="line">            isEnabled = car.shell != null &amp;&amp; car.engine != null &amp;&amp; car.wheel != null &amp;&amp; car.computer != null</span><br><span class="line">            setOnClickListener &#123;</span><br><span class="line">                Toast.makeText(this@MainActivity, &quot;提车咯！&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>抽象是程序员保持优雅的最重要能力。</li>
<li>抽象不应局限在代码层面，而是要上升到业务，乃至技术思维上。</li>
<li>有意识地对代码PUA说：No！</li>
<li>学习新技术时，不应只学会调用，也不应迷失在技术原理上，更重要的是花哨的技术和朴实的编程思想之间的化学反应。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/02/schedule4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="blackfrog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blackfrog">
      <meta itemprop="description" content="blackfrog的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | blackfrog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/02/schedule4/" class="post-title-link" itemprop="url">【Android自定义View】高仿飞书日历--列表视图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-02 12:12:57" itemprop="dateCreated datePublished" datetime="2023-05-02T12:12:57+08:00">2023-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-06 17:52:53" itemprop="dateModified" datetime="2023-09-06T17:52:53+08:00">2023-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%87%AA%E5%AE%9A%E4%B9%89View/" itemprop="url" rel="index"><span itemprop="name">自定义View</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer" />


<p>前段时间，笔者陆续发布了“高仿飞书日历”系列的三篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7217425505925054521">【Android自定义View】高仿飞书日历（一） – 三日视图</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7218459472919085114">【Android自定义View】高仿飞书日历（二） – 日视图</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7219557974847029303">【Android自定义View】高仿飞书日历（三） – 月视图</a></p>
<p>今天继续分享最后一个视图：列表视图。先上效果图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41e9701833a64f75b24fd93a1da203e7~tplv-k3u1fbpfcp-watermark.image" alt="列表视图.gif"></p>
<h2 id="需求确定"><a href="#需求确定" class="headerlink" title="需求确定"></a>需求确定</h2><p>相对来说，这个视图中的交互逻辑要略微复杂一点。</p>
<ul>
<li>列表视图包含两个部分：顶部周&#x2F;月控件，底部日程列表。周&#x2F;月控件显示日期和是否有日程（圆点表示）；日程列表各个Item显示月份、周数、日程等信息。</li>
<li>周&#x2F;月控件可以左右滑动切换周&#x2F;月；可以通过手势或点击箭头来切换周&#x2F;月模式。</li>
<li>在周模式下，日程列表可上下滑动；在月模式下，日程列表向上滑动时切换周模式，禁止向下滑动。</li>
<li>日程列表滑动时选中列表顶部的日期，如果当天有多个日程，滑动过程中日期固定（pin）在列表顶部。</li>
<li>周&#x2F;月控件中可以通过点击选中某一天，选中时，日程列表自动定位到当天的日程；如果被选中的某天没有日程，则显示“暂无日程安排，点击创建”。</li>
<li>在周模式下，如果当前选中了某一天（比如：周三），那么左&#x2F;右滑动后选中上&#x2F;下周的周三。</li>
<li>在月模式下，左&#x2F;右滑动后选中上&#x2F;下月的一号。</li>
</ul>
<h2 id="框架先行"><a href="#框架先行" class="headerlink" title="框架先行"></a>框架先行</h2><h3 id="布局-渲染框架"><a href="#布局-渲染框架" class="headerlink" title="布局&amp;渲染框架"></a>布局&amp;渲染框架</h3><p>从效果图和需求来看，控件整体上是一个Header+List的形式，它们之间存在滑动交互。要实现它，我们很直观地想到<code>CoordinatorLayout</code>（协调布局）。很多同学（包括前两年的笔者）在这时，可能就不管三七二十一，开始翻阅<code>CoordinatorLayout</code>的相关博客，Copy&#x2F;Paste代码了。</p>
<p>请先等一等。</p>
<p>笔者想和大家聊聊一个可能比较重要的问题。</p>
<h4 id="怎样选择技术实现方案？"><a href="#怎样选择技术实现方案？" class="headerlink" title="怎样选择技术实现方案？"></a>怎样选择技术实现方案？</h4><p>当我们接到需求时，基于经验去选择了一个实现方案，如果这个方案我们并不是十分熟悉，需要临时去查阅资料，那么这个实现方案很可能不是适合我们的方案。比如当前这个需求，我们如果选择了不太熟悉的<code>CoordinatorLayout</code>，希望Copy代码就能够帮我们快速实现需求时，可能实际操作起来会让我们失望，甚至让我们陷入进退两难的泥淖。<code>CoordinatorLayout</code>是Google官方针对<code>Material Design</code>，基于<code>NestedScrollingParent/2/3</code>实现的一套UI框架，固然它提供了一些常见的UI效果的快速实现，但这些效果本来就是服务于<code>Material Design</code>的，虽然看起来像，但可能和我们的需求差一点点，这种时候我们只能继续去找解决方案，比如怎么自定义<code>Behavior</code>，甚至需要去了解和调试<code>NestedScrollingParent/2/3</code>的各个方法是怎么协调工作。</p>
<p>一边学习一边调试一边开发需求，渐渐地，我们发现估时不够用了，只能加班、延期或者找产品Battle改需求了。最惨的是，由于学习得很仓促、零碎，脑壳都是昏的，没有系统地理解清楚，即使这次把功能实现了，下次遇到类似的需求又得重新来一遍，心态崩了。。。</p>
<p>如果我精通<code>CoordinatorLayout</code>和<code>NestedScrollingParent/2/3</code>框架，那么我会毫不犹豫地选择它来实现这个需求，但是我明白自己并不熟悉它，可能我强行基于它们来构建代码，很可能会踩到坑里。</p>
<p><strong>当笔者去选择实现方案时，大多是以这样的优先级：本人精通的轮子 &gt; 最基础的API &gt; 官方轮子 &gt; 第三方轮子。</strong></p>
<p>最基础的API虽然实现起来有点麻烦甚至枯燥，但它的优势在于稳定可靠。与其去选择本人不熟悉的<code>CoordinatorLayout</code>和<code>NestedScrollingParent/2/3</code>，还不如退而求其次，选择最笨的方法，用最基础的<code>dispatchTouchEvent/onInterceptTouchEvent/onTouchEvent</code>来处理滑动事宜。</p>
<p>本系列的<a target="_blank" rel="noopener" href="https://juejin.cn/post/7217425505925054521">第一篇</a>中，笔者在做渲染框架时，选择了继承<code>View</code>的方式，而不是基于<code>ScrollView</code>、<code>RecyclerView</code>之类的滑动控件，也是在这个思路下作出的决定。</p>
<p>PS：工作中尽量采用这样的思路去提高工作效率和质量，私底下还是需要花时间学习，补齐短板哟～</p>
<p>言归正传。</p>
<p>和<a target="_blank" rel="noopener" href="https://juejin.cn/post/7219557974847029303">上一篇</a>的月视图一样，我们选择<code>RecyclerView</code>来实现周&#x2F;月控件；同样的，选择<code>RecyclerView</code>来实现日程列表；然后，将它们组合到一个<code>LinearLayout</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 周/月控件</span><br><span class="line">class FlowHeaderGroup @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : RecyclerView(context, attrs) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 日程列表</span><br><span class="line">class ScheduleFlowView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : RecyclerView(context, attrs) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class FlowContainer @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : LinearLayout(context, attrs) &#123;</span><br><span class="line">    private val flowHeader: FlowHeaderGroup</span><br><span class="line">    private val flowHeaderArrow: ImageView</span><br><span class="line">    private val scheduleList: ScheduleFlowView</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布局&amp;渲染框架至此就搭建完成了。</p>
<h3 id="日历框架"><a href="#日历框架" class="headerlink" title="日历框架"></a>日历框架</h3><p>在本系列的<a target="_blank" rel="noopener" href="https://juejin.cn/post/7218459472919085114">第二篇</a>中，我们已经定义好了基于<code>ICalenderRender</code>的日历框架了，这里的实现还是老样子：每个控件都去实现<code>ICalendarRender</code>，如果有子render就实现<code>ICalendarParent</code>。以<code>FlowHeaderGroup</code>为例，它和日视图、月视图中的日历控件实现上几乎是一样的，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class FlowHeaderGroup @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : RecyclerView(context, attrs), ICalendarRender, ICalendarParent &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过也有一点不一样，列表视图中的日历控件，是支持周&#x2F;月模式切换的。简单啊，按照惯例，抽象一个接口为其赋能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface ICalendarModeHolder &#123;</span><br><span class="line">    var calendarMode: CalendarMode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sealed interface CalendarMode &#123;</span><br><span class="line">    data class MonthMode(</span><br><span class="line">        val expandFraction: Float = 0f,</span><br><span class="line">    ) : CalendarMode</span><br><span class="line"></span><br><span class="line">    object WeekMode : CalendarMode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>笔者定义了一个<code>ICalendarModeHolder</code>接口，以及一个密封接口：<code>CalendarMode</code>。为啥要用密封接口而不用枚举呢？因为笔者需要用数据驱动UI。周&#x2F;月模式，被我抽象为<code>CalendarMode</code>；而切换的进度，被我抽象为<code>MonthMode</code>下的<code>expandFraction</code>。这样一来，我们进行滑动操作时，对<code>calendarMode</code>赋值就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 日历收起时</span><br><span class="line">calendarMode = WeekMode</span><br><span class="line">// 日历展开一半时</span><br><span class="line">calendarMode = MonthMode(0.5f)</span><br><span class="line">// 日历完全展开时</span><br><span class="line">calendarMode = MonthMode(1.0f)</span><br></pre></td></tr></table></figure>

<p>相应的，<code>FlowHeaderGroup</code>去实现<code>ICalendarModeHolder</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class FlowHeaderGroup @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : RecyclerView(context, attrs), ICalendarRender, ICalendarParent, ICalendarModeHolder &#123;</span><br><span class="line">    ...</span><br><span class="line">    override var calendarMode: CalendarMode by setter(CalendarMode.WeekMode) &#123; oldMode, mode -&gt;</span><br><span class="line">        if (oldMode is CalendarMode.MonthMode &amp;&amp; mode is CalendarMode.MonthMode) &#123;</span><br><span class="line">            onExpandFraction(mode.expandFraction)</span><br><span class="line">        &#125;</span><br><span class="line">        onCalendarModeSet(mode)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    private fun onExpandFraction(fraction: Float) &#123;</span><br><span class="line">        // TODO 更新布局</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    private fun onCalendarModeSet(mode: CalendarMode) &#123;</span><br><span class="line">        // 周/月模式下，子render的样式也会改变</span><br><span class="line">        childRenders.filterIsInstance&lt;ICalendarModeHolder&gt;().forEach &#123;</span><br><span class="line">            it.calendarMode = mode</span><br><span class="line">        &#125;</span><br><span class="line">        // 周/月模式切换时，更新recyclerView的数据源</span><br><span class="line">        if (mode is CalendarMode.WeekMode || (mode as? CalendarMode.MonthMode)?.expandFraction == 0f) &#123;</span><br><span class="line">            adapter?.notifyDataSetChanged()</span><br><span class="line">            scrollToPosition(selectedDayTime.parseIndex())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，日历框架也搭建完成了。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="滑动手势处理"><a href="#滑动手势处理" class="headerlink" title="滑动手势处理"></a>滑动手势处理</h3><p>有的同学对滑动手势处理望而却步，其实只要一点一点地拆解开，手势处理并不困难，无非是在拦截（<code>onInterceptTouchEvent</code>）和消费（<code>onTouchEvent</code>）这两个过程中，判断和处理我们的滑动手势逻辑。</p>
<p>前面我们已经提到，手势是在父布局（<code>FlowContainer</code>）中处理的。我们要处理的手势状态，主要包括<code>ACTION_DOWN/ACTION_MOVE/ACTION_UP</code>，在这里它们各自的用途是什么呢？</p>
<ul>
<li><code>ACTION_DOWN</code>：重置按下状态（<code>justDown</code>），并记录按下的位置（<code>downX/downY</code>）；</li>
<li><code>ACTION_MOVE</code>：判断滑动方向和方向，进而判断是否拦截；更改周&#x2F;月模式（即：计算并设置<code>calendarMode</code>）；</li>
<li><code>ACTION_UP</code>：计算松手后的速度和位置，进而确定最终的<code>calendarMode</code>。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">class FlowContainer @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : LinearLayout(context, attrs), ICalendarRender, ICalendarParent &#123;</span><br><span class="line">    private val flowHeader: FlowHeaderGroup</span><br><span class="line">    private val flowHeaderArrow: ImageView</span><br><span class="line">    private val scheduleList: ScheduleFlowView</span><br><span class="line"></span><br><span class="line">    // ... 省略掉ICalendarRender的实现</span><br><span class="line"></span><br><span class="line">    private var downX: Float = 0f</span><br><span class="line">    private var downY: Float = 0f</span><br><span class="line">    private var justDown: Boolean = false</span><br><span class="line">    private val touchSlop = ViewConfiguration.getTouchSlop()</span><br><span class="line">    private var intercept = false</span><br><span class="line">    private var fromMonthMode = false</span><br><span class="line"></span><br><span class="line">    private val velocityTracker by lazy &#123;</span><br><span class="line">        VelocityTracker.obtain()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Header（日历控件）底部</span><br><span class="line">    private val headerBottom: Int</span><br><span class="line">        get() = (flowHeaderArrow.parent as View).bottom</span><br><span class="line"></span><br><span class="line">    override fun onTouchEvent(event: MotionEvent): Boolean &#123;</span><br><span class="line">        // 在消费事件时，如果不拦截，则调用默认的super.onTouchEvent(event)</span><br><span class="line">        return performInterceptTouchEvent(event) || super.onTouchEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onInterceptTouchEvent(ev: MotionEvent): Boolean &#123;</span><br><span class="line">        // 在拦截事件时，如果不拦截，则调用默认的super.onInterceptTouchEvent(ev)</span><br><span class="line">        val intercept = performInterceptTouchEvent(ev) || super.onInterceptTouchEvent(ev)</span><br><span class="line">        return intercept</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun performInterceptTouchEvent(ev: MotionEvent): Boolean &#123;</span><br><span class="line">        velocityTracker.addMovement(ev)</span><br><span class="line">        return when (ev.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                downX = ev.x</span><br><span class="line">                downY = ev.y</span><br><span class="line">                justDown = true</span><br><span class="line">                false</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                // 如果justDown为true，就要先判断是否拦截事件</span><br><span class="line">                if (justDown) &#123;</span><br><span class="line">                    fromMonthMode = flowHeader.calendarMode is CalendarMode.MonthMode</span><br><span class="line">                &#125;</span><br><span class="line">                if (justDown &amp;&amp; (abs(downX - ev.x) &gt; touchSlop || abs(downY - ev.y) &gt; touchSlop)) &#123;</span><br><span class="line">                    val moveUp = abs(downX - ev.x) &lt; abs(downY - ev.y) &amp;&amp; ev.y &lt; downY</span><br><span class="line">                    val moveDown = abs(downX - ev.x) &lt; abs(downY - ev.y) &amp;&amp; ev.y &gt; downY</span><br><span class="line">                    // 根据按下位置，滑动方向和当前的calendarMode来判断是否拦截事件</span><br><span class="line">                    intercept = (moveUp &amp;&amp; flowHeader.calendarMode is CalendarMode.MonthMode)</span><br><span class="line">                            || (moveDown &amp;&amp; downY &lt; headerBottom &amp;&amp; flowHeader.calendarMode is CalendarMode.WeekMode)</span><br><span class="line">                            || (moveDown &amp;&amp; downY &gt; headerBottom &amp;&amp; flowHeader.calendarMode is CalendarMode.MonthMode)</span><br><span class="line">                    justDown = false</span><br><span class="line">                &#125;</span><br><span class="line">                if (intercept) &#123; </span><br><span class="line">                    // 在拦截事件时，calendarMode就在MonthMode(0.0f~1.0f)范围内变化了</span><br><span class="line">                    if (!fromMonthMode &amp;&amp; flowHeader.calendarMode is CalendarMode.WeekMode) &#123;</span><br><span class="line">                        flowHeader.calendarMode = CalendarMode.MonthMode(0f)</span><br><span class="line">                    &#125;</span><br><span class="line">                    val maxHeight = (6 * flowHeaderDayHeight)</span><br><span class="line">                    if (fromMonthMode) &#123;</span><br><span class="line">                        flowHeader.calendarMode = CalendarMode.MonthMode(</span><br><span class="line">                            expandFraction = ((maxHeight - downY + ev.y) / maxHeight).coerceAtLeast(0f).coerceAtMost(1f),</span><br><span class="line">                        )</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        flowHeader.calendarMode = CalendarMode.MonthMode(</span><br><span class="line">                            expandFraction = ((flowHeaderDayHeight - downY + ev.y) / maxHeight).coerceAtLeast(</span><br><span class="line">                                0f</span><br><span class="line">                            ).coerceAtMost(1f),</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                    true</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP -&gt; &#123;</span><br><span class="line">                velocityTracker.computeCurrentVelocity(1000)</span><br><span class="line">                val velocity = velocityTracker.yVelocity</span><br><span class="line">                // 当速度绝对值大于1000时，最终位置以速度方向为准；否则，以当前位置为准</span><br><span class="line">                if (intercept &amp;&amp; flowHeader.calendarMode is CalendarMode.MonthMode) &#123;</span><br><span class="line">                    val target = if (velocity &lt; -1000) &#123;</span><br><span class="line">                        CalendarMode.WeekMode</span><br><span class="line">                    &#125; else if (velocity &gt; 1000) &#123;</span><br><span class="line">                        CalendarMode.MonthMode(1f)</span><br><span class="line">                    &#125; else if ((flowHeader.calendarMode as CalendarMode.MonthMode).expandFraction &lt; 0.5f) &#123;</span><br><span class="line">                        CalendarMode.WeekMode</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        CalendarMode.MonthMode(1f)</span><br><span class="line">                    &#125;</span><br><span class="line">                    flowHeader.autoSwitchMode(target.apply &#123;</span><br><span class="line">                        flowHeaderArrow.rotation = if (this is CalendarMode.MonthMode) &#123;</span><br><span class="line">                            0f</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            180f</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                intercept = false</span><br><span class="line">                false</span><br><span class="line">            &#125; </span><br><span class="line">            else -&gt; &#123;</span><br><span class="line">                false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要我们明确每一个手势状态下需要做的事情，那么其实手势处理并不困难吧。</p>
<h3 id="日程列表"><a href="#日程列表" class="headerlink" title="日程列表"></a>日程列表</h3><p>这里的日程列表主要有两个特点：需要显示月、周以及每天的日程数据，即多类型Item；需要上下无限滑动，即需要处理前后的<code>LoadMore</code>。</p>
<p>很多同学可能都准备引入第三方的<code>RecyclerView</code>轮子了，但前面笔者已经提到<code>官方轮子&gt;第三方轮子</code>了，这里我们采用<code>androidx.recyclerview.widget.ListAdapter</code>来实现。</p>
<p><code>ListAdapter</code>的核心思想就是<strong>数据驱动UI</strong>，无论列表中的逻辑再复杂，我们也不需要去手动操作<code>adapter</code>中的数据，只需要在我们的<code>ViewModel</code>或<code>Presenter</code>中构建数据集，然后<code>submitList</code>就完事了。并且，Kotlin给我们提供的丰富而强大的集合扩展方法，大大地简化了我们的数据处理，甚至还提高了性能。</p>
<h4 id="多类型Item"><a href="#多类型Item" class="headerlink" title="多类型Item"></a>多类型Item</h4><p>为了实现多类型，我们先定义一下我们的数据模型（<code>IFlowModel</code>），它也是基于<code>IScheduleModel</code>的，因为我们需要处理排序（<code>Month-&gt;Week-&gt;Day</code>），我们给它添加一个<code>sortValue</code>属性。</p>
<p>然后三种Item类型分别用<code>MonthText/WeekText/FlowDailySchedules</code>来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface IFlowModel : IScheduleModel &#123;</span><br><span class="line">    val sortValue: Long</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data class MonthText(</span><br><span class="line">    override val beginTime: Long,</span><br><span class="line">) : IFlowModel &#123;</span><br><span class="line">    override val sortValue: Long = beginTime</span><br><span class="line">    override val endTime: Long = beginTime.calendar.lastDayOfMonthTime</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data class WeekText(</span><br><span class="line">    override val beginTime: Long,</span><br><span class="line">) : IFlowModel &#123;</span><br><span class="line">    override val sortValue: Long = beginTime + 1</span><br><span class="line">    override val endTime: Long = beginTime + 7 * dayMillis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data class FlowDailySchedules(</span><br><span class="line">    override val beginTime: Long,</span><br><span class="line">    val schedules: List&lt;IScheduleModel&gt;</span><br><span class="line">) : IFlowModel &#123;</span><br><span class="line">    override val sortValue: Long = beginTime + 2</span><br><span class="line">    override val endTime: Long = beginTime + dayMillis</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应的， <code>adapter</code>的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class ScheduleFlowAdapter : ListAdapter&lt;IFlowModel, VH&gt;(</span><br><span class="line">    object : DiffUtil.ItemCallback&lt;IFlowModel&gt;() &#123;</span><br><span class="line">        override fun areItemsTheSame(</span><br><span class="line">            oldItem: IFlowModel,</span><br><span class="line">            newItem: IFlowModel</span><br><span class="line">        ) = oldItem == newItem</span><br><span class="line"></span><br><span class="line">        override fun areContentsTheSame(</span><br><span class="line">            oldItem: IFlowModel,</span><br><span class="line">            newItem: IFlowModel</span><br><span class="line">        ): Boolean &#123;</span><br><span class="line">            if (oldItem is MonthText &amp;&amp; newItem is MonthText) &#123;</span><br><span class="line">                return oldItem.beginTime == newItem.beginTime</span><br><span class="line">            &#125; else if (oldItem is WeekText &amp;&amp; newItem is WeekText) &#123;</span><br><span class="line">                return oldItem.beginTime == newItem.beginTime</span><br><span class="line">            &#125; else if (oldItem is FlowDailySchedules &amp;&amp; newItem is FlowDailySchedules) &#123;</span><br><span class="line">                return oldItem.beginTime == newItem.beginTime &amp;&amp; oldItem.schedules == newItem.schedules</span><br><span class="line">            &#125;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">) &#123;</span><br><span class="line">    private val MONTH_TEXT = 1</span><br><span class="line">    private val WEEK_TEXT = 2</span><br><span class="line">    private val DAILY_TASK = 3</span><br><span class="line">    override fun getItemViewType(position: Int): Int &#123;</span><br><span class="line">        return when (getItem(position)) &#123;</span><br><span class="line">            is MonthText -&gt; MONTH_TEXT</span><br><span class="line">            is WeekText -&gt; WEEK_TEXT</span><br><span class="line">            else -&gt; DAILY_TASK</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH &#123;</span><br><span class="line">        return when (viewType) &#123;</span><br><span class="line">            MONTH_TEXT -&gt; MonthTextVH(parent.context)</span><br><span class="line">            WEEK_TEXT -&gt; WeekTextVH(parent.context)</span><br><span class="line">            else -&gt; DailyTaskVH(</span><br><span class="line">                LayoutInflater.from(parent.context)</span><br><span class="line">                    .inflate(R.layout.flow_daily_item, parent, false)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onBindViewHolder(holder: VH, position: Int) &#123;</span><br><span class="line">        holder.onBind(getItem(position))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class VH(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">    abstract fun onBind(scheduleModel: IScheduleModel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MonthTextVH(context: Context) : VH(TextView(context)) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WeekTextVH(context: Context) : VH(TextView(context)) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DailyTaskVH(itemView: View) : VH(itemView) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建<code>IFlowModel</code>的逻辑看似复杂，其实在数据驱动UI思想和Kotlin语法糖的加持下，可以变得如此简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">override var scheduleModels: List&lt;IScheduleModel&gt; by setter(emptyList()) &#123; _, list -&gt;</span><br><span class="line">    generateViewModels(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private fun generateViewModels(list: List&lt;IScheduleModel&gt;) &#123;</span><br><span class="line">    // 将日程数据按天分组，然后map为FlowDailySchedules</span><br><span class="line">    list.groupBy &#123; it.beginTime.dDays &#125;.values.map &#123;</span><br><span class="line">        FlowDailySchedules(</span><br><span class="line">            beginTime = beginOfDay(it[0].beginTime).timeInMillis,</span><br><span class="line">            schedules = it.sortedBy &#123; model -&gt; model.beginTime &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;.toMutableList&lt;IFlowModel&gt;().apply &#123;</span><br><span class="line">        // 然后在列表中插入月（MonthText）和周（WeekText）</span><br><span class="line">        val days = map &#123; it.beginTime.dDays &#125;</span><br><span class="line">        for (time in beginTime..endTime step dayMillis) &#123;</span><br><span class="line">            if ((time.dDays == nowMillis.dDays || time.dDays == focusedDayTime.dDays) &amp;&amp; !days.contains(</span><br><span class="line">                    time.dDays</span><br><span class="line">                )</span><br><span class="line">            ) &#123;</span><br><span class="line">                add(</span><br><span class="line">                    FlowDailySchedules(</span><br><span class="line">                        beginTime = time,</span><br><span class="line">                        schedules = emptyList()</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            if (time.dayOfMonth == 1) &#123;</span><br><span class="line">                add(MonthText(time))</span><br><span class="line">            &#125;</span><br><span class="line">            if (time.dayOfWeek == Calendar.SUNDAY) &#123;</span><br><span class="line">                add(WeekText(time))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.sortedBy &#123; it.sortValue &#125;.apply &#123; // 最后排序后submitList</span><br><span class="line">        flowAdapter.submitList(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="LoadMore"><a href="#LoadMore" class="headerlink" title="LoadMore"></a>LoadMore</h4><p>看过本系列前面几篇的同学应该记得，咱们的日历框架是基于<code>ITimeRangeHolder</code>的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ITimeRangeHolder &#123;</span><br><span class="line">    val beginTime: Long</span><br><span class="line">    val endTime: Long</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>beginTime</code>和<code>endTime</code>就确定了日历控件的显示范围。那么对于日程列表来说，去更新<code>beginTime</code>和<code>endTime</code>，就能更新日程列表的前后长度，也就实现了LoadMore的效果了。这里仍然是数据驱动UI的体现。</p>
<p>在以下代码中，我们通过监听<code>RecyclerView</code>的滑动，得到当前是否快要滑动到顶&#x2F;底部，然后减小<code>beginTime</code>&#x2F;增大<code>endTime</code>就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">addOnScrollListener(object : OnScrollListener() &#123;</span><br><span class="line">    override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) &#123;</span><br><span class="line">        super.onScrolled(recyclerView, dx, dy)</span><br><span class="line">        val llm = recyclerView.layoutManager as LinearLayoutManager</span><br><span class="line">        val firstVisible = llm.findFirstVisibleItemPosition()</span><br><span class="line">        val lastVisible = llm.findLastVisibleItemPosition()</span><br><span class="line">        checkLoadMore(firstVisible, lastVisible)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">private fun checkLoadMore(firstVisible: Int, lastVisible: Int) &#123;</span><br><span class="line">    if (firstVisible &lt; 10) &#123;</span><br><span class="line">        beginTime = beginTime.calendar.apply &#123;</span><br><span class="line">            add(Calendar.YEAR, -1)</span><br><span class="line">        &#125;.timeInMillis</span><br><span class="line">        if (!loadingMore) &#123;</span><br><span class="line">            loadingMore = true</span><br><span class="line">            reloadSchedulesFromProvider()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (lastVisible &gt; ((adapter?.itemCount ?: 0) - 10).coerceAtLeast(0)) &#123;</span><br><span class="line">        endTime = endTime.calendar.apply &#123;</span><br><span class="line">            add(Calendar.YEAR, 1)</span><br><span class="line">        &#125;.timeInMillis</span><br><span class="line">        if (!loadingMore) &#123;</span><br><span class="line">            loadingMore = true</span><br><span class="line">            reloadSchedulesFromProvider()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新<code>beginTime/endTime</code>后，我们调用<code>reloadSchedulesFromProvider()</code>方法更新数据(<code>scheduleModels</code>)，然后调用前面的<code>generateViewModels</code>方法就行了。</p>
<h2 id="杀割"><a href="#杀割" class="headerlink" title="杀割"></a>杀割</h2><p>更多的实现细节，这里就不展开介绍了，想要详细了解请<a target="_blank" rel="noopener" href="https://github.com/blackfrogxxoo/ScheduleView">移步源码</a>。</p>
<p>整个“高仿飞书日历”项目的构思和实现心得，其实总结起来就这么几点：</p>
<ul>
<li>坚持数据驱动UI思想</li>
<li>面向抽象构建代码</li>
<li>掌握最基本的布局、绘制、滑动手势处理</li>
<li>培养选择技术实现方案的思路</li>
<li>Kotlin赛高！</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/08/schedule3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="blackfrog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blackfrog">
      <meta itemprop="description" content="blackfrog的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | blackfrog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/08/schedule3/" class="post-title-link" itemprop="url">【Android自定义View】高仿飞书日历--月视图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-08 12:12:57" itemprop="dateCreated datePublished" datetime="2023-04-08T12:12:57+08:00">2023-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-06 17:52:48" itemprop="dateModified" datetime="2023-09-06T17:52:48+08:00">2023-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%87%AA%E5%AE%9A%E4%B9%89View/" itemprop="url" rel="index"><span itemprop="name">自定义View</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer" />


<p>前几天笔者陆续发布了“高仿飞书日历”系列的两篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7217425505925054521">【Android自定义View】高仿飞书日历（一） – 三日视图</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7218459472919085114">【Android自定义View】高仿飞书日历（二） – 日视图</a></p>
<p>今天继续分享：月视图。先上效果图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e7a15879bcc460ebd915f6dd6015f14~tplv-k3u1fbpfcp-watermark.image" alt="单月视图.gif"></p>
<h2 id="需求确定"><a href="#需求确定" class="headerlink" title="需求确定"></a>需求确定</h2><p>月视图的显示和交互相对简单一点。</p>
<ul>
<li>每页展示一个月的月历，左右滑动切换上&#x2F;下月。</li>
<li>月历中每天的日期下展示当天的日程名称列表，如果展示不完整则在日期右侧展示剩余日程数。</li>
<li>点击选中某一天时，以这一天所在的周，上下展开。展开时，在中间显示详细的日程列表，如果没有日程则显示空页面。左右滑动切换上&#x2F;下一天。</li>
<li>展开状态下，日程列表可以左右滑动。点击选中的日期可收起日程列表，点击其他日期可切换日程列表。</li>
</ul>
<h2 id="框架先行"><a href="#框架先行" class="headerlink" title="框架先行"></a>框架先行</h2><h3 id="布局-渲染框架"><a href="#布局-渲染框架" class="headerlink" title="布局&amp;渲染框架"></a>布局&amp;渲染框架</h3><p>为便于理解，我们不妨将月视图的布局分为外层和内层。</p>
<h4 id="外层"><a href="#外层" class="headerlink" title="外层"></a>外层</h4><p>从效果图和需求中可以看出，月视图整体上就是一个左右翻页控件，那么<code>ViewPager/ViewPager2/RecyclerView</code>都是可以考虑的。笔者对<code>RecyclerView</code>比较熟悉，就选用了<code>RecyclerView</code>+<code>PagerSnapHelper</code>来构建了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MonthGroup @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : RecyclerView(context, attrs) &#123;</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        layoutManager = LinearLayoutManager(context, HORIZONTAL, false)</span><br><span class="line">        PagerSnapHelper().attachToRecyclerView(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前在外层布局构建阶段，那就暂时不考虑内层的布局细节了。我们可以考虑组合<code>GridView</code>和<code>ViewPager</code>这样的方式来构建月历布局，但笔者喜欢自由发挥，就先用一个自定义<code>ViewGroup</code>占坑吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MonthView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0</span><br><span class="line">) : ViewGroup(context, attrs, defStyleAttr) &#123;</span><br><span class="line"></span><br><span class="line">    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) &#123;</span><br><span class="line">        // TODO 布局</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为<code>MonthGroup</code>定义一个<code>adapter</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MonthAdapter : RecyclerView.Adapter&lt;VH&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    private val monthCount: Int = 0 // TODO 计算月份数</span><br><span class="line"></span><br><span class="line">    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH &#123;</span><br><span class="line">        return VH(parent.context)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getItemCount() = monthCount</span><br><span class="line"></span><br><span class="line">    override fun onBindViewHolder(holder: VH, position: Int) &#123;</span><br><span class="line">        // TODO 为MonthView绑定日期和日程数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class VH(context: Context) : ViewHolder(MonthView(context).apply &#123;</span><br><span class="line">    layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>让<code>MonthGroup</code>绑定一个adapter，为了拿到当前的月份，我们定义一个<code>lastPosition</code>字段，并在<code>OnScrollListener</code>中计算更新<code>lastPosition</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MonthGroup @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : RecyclerView(context, attrs) &#123;</span><br><span class="line">    private var lastPosition = -1</span><br><span class="line">    init &#123;</span><br><span class="line">        layoutManager = LinearLayoutManager(context, HORIZONTAL, false)</span><br><span class="line">        PagerSnapHelper().attachToRecyclerView(this)</span><br><span class="line">        adapter = MonthAdapter()</span><br><span class="line">        </span><br><span class="line">        addOnScrollListener(object : OnScrollListener() &#123;</span><br><span class="line">            override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) &#123;</span><br><span class="line">                if (newState == SCROLL_STATE_IDLE) &#123;</span><br><span class="line">                    val llm = recyclerView.layoutManager as LinearLayoutManager</span><br><span class="line">                    val position = llm.findFirstCompletelyVisibleItemPosition()</span><br><span class="line">                    if (position != -1 &amp;&amp; lastPosition != position) &#123;</span><br><span class="line">                        lastPosition = position</span><br><span class="line">                        // TODO 处理选中某月份的逻辑</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样月视图的外层布局&amp;渲染框架就完成了。</p>
<h4 id="内层"><a href="#内层" class="headerlink" title="内层"></a>内层</h4><p>考虑一下，效果图中，显示“日 一 二 三..”那一行(header)是固定的，也不可交互，我们可以直接在<code>onDraw()</code>方法中绘制它们。而日期Item和日程列表的布局需要处理动态更新，在<code>onLayout()</code>中去处理更加直观。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MonthView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0</span><br><span class="line">) : ViewGroup(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    private val paint = Paint(Paint.ANTI_ALIAS_FLAG).apply &#123;</span><br><span class="line">        textSize = 11f.dp</span><br><span class="line">    &#125;</span><br><span class="line">    private val topPadding = 26f.dp</span><br><span class="line">    init &#123;</span><br><span class="line">        setWillNotDraw(false)</span><br><span class="line">        // topPadding以上用于绘制周header，以下用于布局子View</span><br><span class="line">        updatePadding(top = topPadding.roundToInt())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDraw(canvas: Canvas) &#123;</span><br><span class="line">        super.onDraw(canvas)</span><br><span class="line">        paint.color = ScheduleConfig.colorBlack3</span><br><span class="line">        // TODO 绘制header</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) &#123;</span><br><span class="line">        // TODO 布局日期Item和日程列表</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日期Item中需要绘制日期、日程和选中状态，就简单地自定义一个<code>View</code>来渲染吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class DayView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0</span><br><span class="line">) : View(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    private val paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">    override fun onDraw(canvas: Canvas) &#123;</span><br><span class="line">        super.onDraw(canvas)</span><br><span class="line">        drawDate(canvas)</span><br><span class="line">        drawTasks(canvas)</span><br><span class="line">        drawArrow(canvas)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun drawDate(canvas: Canvas) &#123;</span><br><span class="line">        // TODO 绘制日期</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun drawTasks(canvas: Canvas) &#123;</span><br><span class="line">        // TODO 绘制日程</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun drawArrow(canvas: Canvas) &#123;</span><br><span class="line">        // TODO 绘制选中箭头</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，我们需要让每一个<code>MonthView</code>去添加一些<code>DayView</code>到它的布局中。简单处理，就在<code>onAttachedToWindow()</code>中添加，在<code>onDetachedFromWindow()</code>中清除好了。添加多少个呢？这就需要根据日历数据去计算了，这里暂时不处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MonthView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0</span><br><span class="line">) : ViewGroup(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    ...</span><br><span class="line">    override fun onAttachedToWindow() &#123;</span><br><span class="line">        super.onAttachedToWindow()</span><br><span class="line">        // TODO addView(DayView(context))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDetachedFromWindow() &#123;</span><br><span class="line">        super.onDetachedFromWindow()</span><br><span class="line">        removeAllViews()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别忘了还有一个展开状态，我们需要再添加一个日程列表在<code>MonthView</code>中，这个日程列表是可以左右滑动的，我们继承一个<code>RecyclerView</code>来实现，它就是一个常规的<code>RecyclerView</code>的使用，比较枯燥，这里就点到为止了哈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 日程列表外层</span><br><span class="line">class DailyTaskListViewGroup @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : RecyclerView(context, attrs) &#123;</span><br><span class="line">    ...</span><br><span class="line">    inner class Adapter() :</span><br><span class="line">        RecyclerView.Adapter&lt;VH&gt;() &#123;</span><br><span class="line">        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH &#123;</span><br><span class="line">            return VH(DailyTaskListView(parent.context).apply &#123;</span><br><span class="line">                layoutParams = LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun getItemCount() = 7</span><br><span class="line"></span><br><span class="line">        override fun onBindViewHolder(holder: VH, position: Int) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class VH(val dailyTaskListView: DailyTaskListView) : ViewHolder(dailyTaskListView)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 日程列表内层，包含一个上下滑动的日程列表和一个空页面</span><br><span class="line">class DailyTaskListView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : FrameLayout(context, attrs) &#123;</span><br><span class="line">    private val recyclerView: RecyclerView</span><br><span class="line">    private val emptyView: TextView</span><br><span class="line">    init &#123;</span><br><span class="line">        inflate(context, R.layout.daily_task_list_view, this)</span><br><span class="line">        recyclerView = findViewById(R.id.recyclerView)</span><br><span class="line">        emptyView = findViewById(R.id.emptyView)</span><br><span class="line">        emptyView.text = buildSpannedString &#123;</span><br><span class="line">            append(&quot;暂无日程安排，&quot;)</span><br><span class="line">            color(ScheduleConfig.colorBlue1) &#123;</span><br><span class="line">                append(&quot;点击创建&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        emptyView.setOnClickListener &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inner class Adapter : RecyclerView.Adapter&lt;ViewHolder&gt;() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class VH(itemView: View) : ViewHolder(itemView) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们把日程列表<code>DailyTaskListViewGroup</code>直接添加到<code>MonthView</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MonthView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0</span><br><span class="line">) : ViewGroup(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    private val dailyTaskListViewGroup: DailyTaskListViewGroup</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        setWillNotDraw(false)</span><br><span class="line">        updatePadding(top = topPadding.roundToInt())</span><br><span class="line">        dailyTaskListViewGroup = DailyTaskListViewGroup(context).apply &#123;</span><br><span class="line">            layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)</span><br><span class="line">            setBackgroundColor(ScheduleConfig.colorBlack6)</span><br><span class="line">        &#125;</span><br><span class="line">        addView(dailyTaskListViewGroup)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDetachedFromWindow() &#123;</span><br><span class="line">        super.onDetachedFromWindow()</span><br><span class="line">        // 只移除DayView，保留DailyTaskListViewGroup</span><br><span class="line">        removeViews(1, childCount - 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的布局&amp;渲染框架就完成了。</p>
<h3 id="日历框架"><a href="#日历框架" class="headerlink" title="日历框架"></a>日历框架</h3><p>在<a target="_blank" rel="noopener" href="https://juejin.cn/post/7218459472919085114">上一篇</a>中我们已经定义好了日历框架，接下来，我们将给月视图绑定日历框架，并且让月视图和三日&#x2F;日视图联系起来。</p>
<p>在上一篇文章中，我们已经演示过日历框架的应用方式了。和日视图中的周控件一样，我们也让月视图相关的组件去实现<code>ICalendarRender</code>和<code>ICalendarParent</code>接口。由于相关控件比较多，这里就只贴一下<code>MonthGroup</code>的代码了，其他组件中的实现差不多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class MonthGroup @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : RecyclerView(context, attrs), ICalendarRender, ICalendarParent &#123;</span><br><span class="line">    override val parentRender: ICalendarRender? = null</span><br><span class="line">    override val calendar: Calendar = beginOfDay()</span><br><span class="line">    override var selectedDayTime: Long by setter(nowMillis) &#123; _, time -&gt;</span><br><span class="line">        if (!isVisible) return@setter</span><br><span class="line">        childRenders.forEach &#123; it.selectedDayTime = time &#125;</span><br><span class="line">        post &#123;</span><br><span class="line">            val position = time.parseMonthIndex()</span><br><span class="line">            if (abs(lastPosition - position) &lt; 5) &#123;</span><br><span class="line">                smoothScrollToPosition(position)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                scrollToPosition(position)</span><br><span class="line">            &#125;</span><br><span class="line">            lastPosition = position</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override var scheduleModels: List&lt;IScheduleModel&gt; by setter(emptyList()) &#123; _, list -&gt;</span><br><span class="line">        childRenders.forEach &#123; it.getSchedulesFrom(list) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override val beginTime: Long</span><br><span class="line">        get() = ScheduleConfig.scheduleBeginTime</span><br><span class="line">    override val endTime: Long</span><br><span class="line">        get() = ScheduleConfig.scheduleEndTime</span><br><span class="line">    override val childRenders: List&lt;ICalendarRender&gt;</span><br><span class="line">        get() = children.filterIsInstance&lt;ICalendarRender&gt;().toList()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意一下，当<code>ViewGroup</code>实现了<code>ICalendarParent</code>时，可以直接利用<code>filterIsInstance()</code>方法，在<code>ViewGroup</code>的<code>children</code>中遍历<code>childRenders</code>。不禁感叹，<strong>Kotlin特性可以大大简化我们的代码，并且能给我们编码提供更多想象空间。</strong></p>
<p>至此，我们的框架部分就搭建完成了。接下来，介绍一下部分具体实现。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="添加和布局DayView"><a href="#添加和布局DayView" class="headerlink" title="添加和布局DayView"></a>添加和布局DayView</h3><p>首先，我们需要计算<code>MonthView</code>中<code>DayView</code>的个数，这里我们可以利用<code>Calendar</code>计算出来。</p>
<p>咱们<code>ICalendarRender</code>不是实现了<code>ITimeRangeHolder</code>吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface ITimeRangeHolder &#123; </span><br><span class="line">    val beginTime: Long </span><br><span class="line">    val endTime: Long </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ICalendarRender : ITimeRangeHolder</span><br></pre></td></tr></table></figure>

<p>只要确定(实现)了<code>MonthView</code>中的<code>beginTime</code>和<code>endTime</code>，那么<code>(endTime - beginTime) / dayMillis</code>就是<code>DayView</code>的个数了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 当月第一天所在周的周日</span><br><span class="line">override val beginTime: Long</span><br><span class="line">    get() = beginOfDay(calendar.firstDayOfMonthTime).apply &#123;</span><br><span class="line">        set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY)</span><br><span class="line">    &#125;.timeInMillis</span><br><span class="line">// 当月最后一天所在周的周六</span><br><span class="line">override val endTime: Long</span><br><span class="line">    get() = beginOfDay(calendar.lastDayOfMonthTime).apply &#123;</span><br><span class="line">        set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY)</span><br><span class="line">    &#125;.timeInMillis</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以在<code>onAttachedToWindow()</code>和<code>onLayout()</code>中处理<code>DayView</code>的添加、初始化和布局了。</p>
<p>PS：这里的<code>onLayout()</code>和日视图中的<code>WeekView</code>中的代码完全一样，哈哈！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">override fun onAttachedToWindow() &#123;</span><br><span class="line">    super.onAttachedToWindow()</span><br><span class="line">    for (time in beginTime..endTime step dayMillis) &#123;</span><br><span class="line">        DayView(context).let &#123; child -&gt;</span><br><span class="line">            child.calendar.timeInMillis = time</span><br><span class="line">            addView(child)</span><br><span class="line">            // 老样子，从parentRender中截取scheduleModels</span><br><span class="line">            if (scheduleModels.any()) &#123;</span><br><span class="line">                child.getSchedulesFrom(scheduleModels)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) &#123;</span><br><span class="line">    for (index in 0 until childCount) &#123;</span><br><span class="line">        val child = getChildAt(index)</span><br><span class="line">        val calendar = (child as ICalendarRender).calendar</span><br><span class="line">        val dDays = calendar.timeInMillis.dDays - beginTime.dDays</span><br><span class="line">        val line = dDays / 7</span><br><span class="line">        val left = dDays % 7 * dayWidth</span><br><span class="line">        val top = paddingTop + line * dayHeight</span><br><span class="line">        val right = left + dayWidth</span><br><span class="line">        val bottom = top + dayHeight</span><br><span class="line">        if (top.isNaN()) continue</span><br><span class="line">        child.layout(</span><br><span class="line">            left.roundToInt(),</span><br><span class="line">            top.roundToInt(),</span><br><span class="line">            right.roundToInt(),</span><br><span class="line">            bottom.roundToInt()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="展开和收起"><a href="#展开和收起" class="headerlink" title="展开和收起"></a>展开和收起</h3><p>要实现展开和收起，根本上来说就是要改变<code>DayView</code>在<code>MonthView</code>中的位置（废话）。那么<code>DayView</code>的位置怎么改变呢，刚刚写的<code>onLayout()</code>方法中处理呗，让它的<code>top</code>可变就行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) &#123;</span><br><span class="line">    for (index in 0 until childCount) &#123;</span><br><span class="line">        ...</span><br><span class="line">        var top = paddingTop + line * dayHeight</span><br><span class="line">        // TODO top = ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>仔细看，点击<code>DayView</code>展开时，<code>DayView</code>所在的那一周向上滑动到顶部，下一周向下滑动到底部。</p>
<p>我们可以这样理解：展开时，有一条中心线(<code>collapseCenter</code>)，有一条线（<code>collapseTop</code>）从中心线开始向上挤，另一条线（<code>collapseBottom</code>）从中心线开始向下挤。</p>
<p><code>collapseCenter</code>是根据展开的那一周的行数(<code>collapseLine</code>)确定的，而<code>collapseTop</code>和<code>collapseBottom</code>是基于<code>collapseCenter</code>在展开动画中动态变化到目标位置的。</p>
<p>另外别忘了哦，展开时中间的日程列表<code>DailyTaskListViewGroup</code>和其他<code>ICalendarRender</code>一样，展开时需要为<code>DailyTaskListViewGroup</code>设置<code>calendar</code>和<code>scheduleModels</code>数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// &gt; -1，展开； == -1，收起</span><br><span class="line">private var collapseLine = -1</span><br><span class="line">    set(value) &#123;</span><br><span class="line">        onCollapseLineChanged(field, value)</span><br><span class="line">        field = value</span><br><span class="line">    &#125;</span><br><span class="line">private var animatingCollapseLine = -1</span><br><span class="line">private var collapseCenter: Float = -1f</span><br><span class="line">private var collapseTop: Float = -1f</span><br><span class="line">private var collapseBottom: Float = -1f</span><br><span class="line"></span><br><span class="line">override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) &#123;</span><br><span class="line">    for (index in 0 until childCount) &#123;</span><br><span class="line">        ...</span><br><span class="line">        var top = paddingTop + line * dayHeight</span><br><span class="line">        if (animatingCollapseLine &gt;= 0) &#123;</span><br><span class="line">            if (line &lt;= animatingCollapseLine) &#123;</span><br><span class="line">                top -= collapseCenter - collapseTop</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                top += collapseBottom - collapseCenter</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private fun onCollapseLineChanged(old: Int, new: Int, doOnCollapsed: () -&gt; Unit = &#123;&#125;) &#123;</span><br><span class="line">    if (old == -1 &amp;&amp; new &gt;= 0) &#123; // 从收起到展开</span><br><span class="line">        // 展开时更新DailyTaskListViewGroup的日期和日程数据</span><br><span class="line">        dailyTaskListViewGroup.calendar.timeInMillis = beginTime + new * 7 * dayMillis</span><br><span class="line">        dailyTaskListViewGroup.getSchedulesFrom(scheduleModels)</span><br><span class="line">        collapseCenter = paddingTop + (new + 1) * dayHeight</span><br><span class="line">        val destTop = paddingTop + dayHeight</span><br><span class="line">        val destBottom = if (new &lt; childCount / 7 - 1) &#123;</span><br><span class="line">            paddingTop + (childCount / 7 - 1) * dayHeight</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            paddingTop + childCount / 7 * dayHeight</span><br><span class="line">        &#125;</span><br><span class="line">        ValueAnimator.ofFloat(0f, 1f).apply &#123;</span><br><span class="line">            doOnStart &#123;</span><br><span class="line">                animatingCollapseLine = new</span><br><span class="line">            &#125;</span><br><span class="line">            doOnEnd &#123;</span><br><span class="line">                animatingCollapseLine = new</span><br><span class="line">            &#125;</span><br><span class="line">            duration = 300</span><br><span class="line">            addUpdateListener &#123;</span><br><span class="line">                collapseTop = collapseCenter + (destTop - collapseCenter) * it.animatedFraction</span><br><span class="line">                collapseBottom =</span><br><span class="line">                    collapseCenter + (destBottom - collapseCenter) * it.animatedFraction</span><br><span class="line">                requestLayout()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125; else if (old &gt;= 0 &amp;&amp; new == -1) &#123; // 从展开到收起</span><br><span class="line">        dailyTaskListViewGroup.calendar.timeInMillis = -1</span><br><span class="line">        dailyTaskListViewGroup.scheduleModels = emptyList()</span><br><span class="line">        collapseCenter = paddingTop + (old + 1) * dayHeight</span><br><span class="line">        val startTop = collapseTop</span><br><span class="line">        val startBottom = collapseBottom</span><br><span class="line">        ValueAnimator.ofFloat(0f, 1f).apply &#123;</span><br><span class="line">            doOnStart &#123;</span><br><span class="line">                animatingCollapseLine = old</span><br><span class="line">            &#125;</span><br><span class="line">            doOnEnd &#123;</span><br><span class="line">                animatingCollapseLine = new</span><br><span class="line">                doOnCollapsed.invoke()</span><br><span class="line">            &#125;</span><br><span class="line">            duration = 300</span><br><span class="line">            addUpdateListener &#123;</span><br><span class="line">                collapseTop = startTop + (collapseCenter - startTop) * it.animatedFraction</span><br><span class="line">                collapseBottom =</span><br><span class="line">                    startBottom + (collapseCenter - startBottom) * it.animatedFraction</span><br><span class="line">                requestLayout()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125; else if (old != new &amp;&amp; old &gt;= 0 &amp;&amp; new &gt;= 0) &#123; // 从展开第a行到展开第b行，连续调用两次</span><br><span class="line">        onCollapseLineChanged(old, -1) &#123;</span><br><span class="line">            onCollapseLineChanged(-1, new)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h3><p>日程列表<code>DailyTaskListViewGroup</code>中是横向<code>RecyclerView</code>嵌套纵向<code>RecyclerView</code>，<code>MonthGroup</code>又是一个横向<code>RecyclerView</code>，所以我们需要处理一下滑动冲突。</p>
<p>简单来说，就是在我们左右滑动日程列表时，通过调用<code>parent.requestDisallowInterceptTouchEvent(true)</code>，不让父布局拦截事件就行了。这边简单贴一下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">open class StableOrientationRecyclerView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : RecyclerView(context, attrs) &#123;</span><br><span class="line">    private var downX = 0f</span><br><span class="line">    private var downY = 0f</span><br><span class="line">    private var justDown = false</span><br><span class="line">    private val isHorizontal: Boolean</span><br><span class="line">        get() = (layoutManager as? LinearLayoutManager)?.orientation == HORIZONTAL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private val touchSlop = ViewConfiguration.getTouchSlop()</span><br><span class="line"></span><br><span class="line">    override fun dispatchTouchEvent(e: MotionEvent): Boolean &#123;</span><br><span class="line">        when (e.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                downX = e.x</span><br><span class="line">                downY = e.y</span><br><span class="line">                justDown = true</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                if (justDown &amp;&amp; (abs(downX - e.x) &gt; touchSlop || abs(downY - e.y) &gt; touchSlop)) &#123;</span><br><span class="line">                    val moveHorizontal = abs(downX - e.x) &gt; abs(downY - e.y)</span><br><span class="line">                    if (moveHorizontal == isHorizontal) &#123;</span><br><span class="line">                        parent.requestDisallowInterceptTouchEvent(true)</span><br><span class="line">                    &#125;</span><br><span class="line">                    justDown = false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP -&gt; &#123;</span><br><span class="line">                justDown = false</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(false)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.dispatchTouchEvent(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后让<code>DailyTaskListViewGroup</code>继承<code>StableOrientationRecyclerView</code>就完事了。</p>
<h2 id="杀割"><a href="#杀割" class="headerlink" title="杀割"></a>杀割</h2><p>本文介绍的月视图，相对于三日&#x2F;日视图来说，更加接近平时我们在工作中接到的需求，做起来比较枯燥一点。好在有先前就定义好的日历框架加持，笔者在做实现时还比较顺畅。</p>
<p>后面笔者将介绍最后一个日程视图了，先贴一张效果图预告，感兴趣的朋友可以关注一下。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da24e40285134cfab25eb37c91b7cb7c~tplv-k3u1fbpfcp-watermark.image" alt="列表视图.gif"></p>
<p>最后贴一下<a target="_blank" rel="noopener" href="https://github.com/blackfrogxxoo/ScheduleView/tree/master/widget/src/main/java/me/wxc/widget/calender">代码地址</a>，欢迎star和issues。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/05/schedule2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="blackfrog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blackfrog">
      <meta itemprop="description" content="blackfrog的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | blackfrog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/05/schedule2/" class="post-title-link" itemprop="url">【Android自定义View】高仿飞书日历--日视图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-05 12:12:57" itemprop="dateCreated datePublished" datetime="2023-04-05T12:12:57+08:00">2023-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-06 17:52:43" itemprop="dateModified" datetime="2023-09-06T17:52:43+08:00">2023-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%87%AA%E5%AE%9A%E4%B9%89View/" itemprop="url" rel="index"><span itemprop="name">自定义View</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer" />


<p>在上一篇<a target="_blank" rel="noopener" href="https://juejin.cn/post/7217425505925054521/">【Android自定义View】高仿飞书日历（一） – 三日视图</a>中，我们实现了飞书日历中的三日视图，今天趁热打铁，介绍一下日视图的实现思路和细节，先上效果图。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55dec879ccfd42a591aea25397ce25c5~tplv-k3u1fbpfcp-watermark.image" alt="单日视图.gif"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7274b8b4baf84cbfb299745ed83d723b~tplv-k3u1fbpfcp-watermark.image" alt="单日2.gif"></p>
<h2 id="需求确定"><a href="#需求确定" class="headerlink" title="需求确定"></a>需求确定</h2><p>对比三日视图，日视图在渲染、滑动、拖曳等方面几乎完全一致，只是一天的显示宽度（<code>dayWidth</code>）是三日视图的三倍。</p>
<p>不同的点在于：</p>
<ul>
<li>三日视图中，左右滑动时，没有距离限制，只需保证静止时保持<code>scrollX</code>等于<code>N * dayWidth</code>就行；日视图中，左右滑动时，每次最多只能滑动<code>dayWidth</code>。</li>
<li>三日视图中，横坐标轴显示三天的日期，与坐标区同步左右滑动；日视图中，横坐标轴显示整周的日期，独立滑动，但与坐标区的滑动是互动的。</li>
<li>三日视图中，当前选中的日期（<code>selectedDayTime</code>）这个数据（或者说概念）是模糊的；日视图中，<code>selectedDayTime</code>变得清晰。左右滑动结束时，当前显示的那一天就是<code>selectedDayTime</code>，相应的，横坐标显示的也是这一天所在的一周，并且对<code>selectedDayTime</code>有高亮处理。</li>
</ul>
<h2 id="框架先行"><a href="#框架先行" class="headerlink" title="框架先行"></a>框架先行</h2><h3 id="渲染-滑动框架"><a href="#渲染-滑动框架" class="headerlink" title="渲染&amp;滑动框架"></a>渲染&amp;滑动框架</h3><p>既然日视图和三日视图的需求大致相同，那么渲染和滑动框架，我们也可以复用三日视图，甚至我们不需要去定义一个新的实现类，只需要让<code>ScheduleView</code>拥有切换模式的能力就行了。由于<code>ScheduleView</code>的布局是由<code>ScheduleWidget</code>管理的，所以我们给<code>IScheduleWidget</code>增加切换视图的能力：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface IScheduleWidget &#123;</span><br><span class="line">    val render: IScheduleRender</span><br><span class="line">    fun onTouchEvent(motionEvent: MotionEvent): Boolean</span><br><span class="line">    fun onScroll(x: Int, y: Int)</span><br><span class="line">    fun scrollTo(x: Int, y: Int, duration: Int = 250)</span><br><span class="line">    fun isScrolling(): Boolean</span><br><span class="line">    </span><br><span class="line">    // 切换视图</span><br><span class="line">    val renderRange: RenderRange</span><br><span class="line">    sealed interface RenderRange &#123;</span><br><span class="line">        object SingleDayRange : RenderRange</span><br><span class="line">        object ThreeDayRange : RenderRange</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但还有一个问题，日视图的横轴是独立滑动的，我们可以像处理拖曳日程那样处理，但想来处理起来会很麻烦。<strong>《代码大全》里面说过，软件工程的核心是控制复杂度。</strong><br>处理拖曳日程已经让我们的代码复杂度提高了一个等级，经（jing）验（chang）丰（jia）富（ban）的开发都有意识——在已经产生复杂度的代码上增加复杂度，会导致复杂度指数级提高。</p>
<h3 id="组合ViewGroup"><a href="#组合ViewGroup" class="headerlink" title="组合ViewGroup"></a>组合ViewGroup</h3><p>笔者的处理方式是，在<code>ScheduleView</code>外面加一层父布局，单独写一个周控件与<code>ScheduleView</code>进行组合，周控件暂且就用<code>RecyclerView</code>实现。</p>
<p>这时，有的朋友可能会问，github上那么多优秀的开源日历项目，为啥还要重复造轮子呢？我先卖个关子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ScheduleGroup @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : FrameLayout(context, attrs) &#123;</span><br><span class="line">    private val scheduleView: ScheduleView</span><br><span class="line">    private val weekList: RecyclerView</span><br><span class="line">    private val weekAdapter: WeekAdapter</span><br><span class="line">    </span><br><span class="line">    init &#123;</span><br><span class="line">        inflate(context, R.layout.schedule_group, this)</span><br><span class="line">        scheduleView = findViewById(R.id.scheduleView)</span><br><span class="line">        weekList = findViewById(R.id.weekList)</span><br><span class="line">        PagerSnapHelper().attachToRecyclerView(weekList)</span><br><span class="line">        weekAdapter = WeekAdapter(weekList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>schedule_group</code>布局很简单，就是一个<code>FrameLayout</code>中加了一个<code>ScheduleView</code>和一个<code>RecyclerView</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:parentTag=&quot;android.widget.FrameLayout&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;me.wxc.widget.schedule.ScheduleView</span><br><span class="line">        android:id=&quot;@+id/scheduleView&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">        android:id=&quot;@+id/weekList&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;60dp&quot;</span><br><span class="line">        android:layout_marginStart=&quot;56dp&quot;</span><br><span class="line">        android:orientation=&quot;horizontal&quot;</span><br><span class="line">        android:visibility=&quot;invisible&quot;</span><br><span class="line">        app:layoutManager=&quot;androidx.recyclerview.widget.LinearLayoutManager&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure>

<p>之前我们需要在<code>Activity</code>中维护<code>ScheduleWidget</code>，现在有了父布局，我们就可以在父布局中维护<code>ScheduleWidget</code>了，这不正是<strong>代理模式</strong>的应用场景吗？我们让<code>ScheduleGroup</code>实现<code>IScheduleWidget</code>接口，并持有一个<code>ScheduleWidget</code>的实例，<code>ScheduleGroup</code>就可以作为<code>ScheduleWidget</code>的<strong>代理</strong>了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ScheduleGroup @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null</span><br><span class="line">) : FrameLayout(context, attrs), IScheduleWidget &#123;</span><br><span class="line">    private val scheduleView: ScheduleView</span><br><span class="line">    private val weekList: RecyclerView</span><br><span class="line">    private val weekAdapter: WeekAdapter</span><br><span class="line">    private val scheduleWidget: ScheduleWidget</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        inflate(context, R.layout.schedule_group, this)</span><br><span class="line">        scheduleView = findViewById(R.id.scheduleView)</span><br><span class="line">        scheduleWidget = ScheduleWidget(scheduleView)</span><br><span class="line">        weekList = findViewById(R.id.weekList)</span><br><span class="line">        PagerSnapHelper().attachToRecyclerView(weekList)</span><br><span class="line">        weekAdapter = WeekAdapter(weekList)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override val render: IScheduleRender</span><br><span class="line">        get() = scheduleView</span><br><span class="line">    override val renderRange: IScheduleWidget.RenderRange</span><br><span class="line">        get() = scheduleWidget.renderRange</span><br><span class="line"></span><br><span class="line">    override fun onScroll(x: Int, y: Int) &#123;</span><br><span class="line">        scheduleWidget.onScroll(x, y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun scrollTo(x: Int, y: Int, duration: Int) &#123;</span><br><span class="line">        scheduleWidget.scrollTo(x, y, duration)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun isScrolling(): Boolean = scheduleWidget.isScrolling()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做还有一个好处，就是让咱们的整个日历（包括三日、日、月、日程）有了<strong>树状结构</strong>的雏形，这部分马上展开讲。</p>
<h3 id="日历框架"><a href="#日历框架" class="headerlink" title="日历框架"></a>日历框架</h3><p>在上一篇中，我们将三日视图上显示的各种组件，抽象成了<code>IScheduleModel</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IScheduleModel &#123;</span><br><span class="line">    val beginTime: Long</span><br><span class="line">    val endTime: Long</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>认真看到现在的朋友，都可以看出来，笔者一直秉持着<strong>面向抽象编程</strong>的思想在构建代码。而我们现在需要新增一个周控件，并且新加了一个<code>selectedDayTime</code>的概念，它又怎么抽象呢？</p>
<p>仔细看日视图的效果图，我们需要考虑把<strong>日程数据</strong>与<strong>日历控件</strong>区别开了。比如我们的周控件，它是日历控件，但不是日程数据；它有着beginTime-endTime的骨骼，但同时又是日程数据的承载者。</p>
<p>于是，我们需要将原来的<code>IScheduleModel</code>进一步抽象。</p>
<p>不具有数据属性的beginTime-endTime，就抽象为<code>ITimeRangeHolder</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ITimeRangeHolder &#123;</span><br><span class="line">    val beginTime: Long</span><br><span class="line">    val endTime: Long</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而具有数据属性的<code>IScheduleModel</code>，就去实现<code>java.io.Serializable</code>接口，这也是为以后数据存储和传输作准备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface IScheduleModel : ITimeRangeHolder, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>有了这个抽象基础，我们终于可以对<strong>日历控件</strong>进行抽象了。日历控件需要一个<code>Calendar</code>属性来标定它的时间，一个<code>List&lt;IScheduleModel&gt;</code>来维护日程数据，并且<code>selectedDayTime</code>这一概念也可以定义为它的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ICalendarRender : ITimeRangeHolder &#123;</span><br><span class="line">    val calendar: Calendar</span><br><span class="line">    var selectedDayTime: Long</span><br><span class="line">    var scheduleModels: List&lt;IScheduleModel&gt;</span><br></pre></td></tr></table></figure>

<p>另外，考虑到日历有年-月-周-日这样的层次，我们可以开始考虑层次结构的问题了。这里我们又模仿<code>View</code>的api，给我们的<code>ICalendarRender</code>添加一个<code>parentRender</code>。顶层的<code>ICalendarRender</code>是没有<code>parentRender</code>的，所以它是可空的。类似<code>View</code>中的<code>parent</code>，这个<code>parentRender</code>给我们提供了<strong>向上遍历</strong>的基础。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ICalendarRender : ITimeRangeHolder &#123;</span><br><span class="line">    ...</span><br><span class="line">    val parentRender: ICalendarRender?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应的，可以拥有子<code>ICalendarRendar</code>的组件，也应该具有<strong>向下遍历</strong>的能力：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface ICalendarParent &#123;</span><br><span class="line">    val childRenders: List&lt;ICalendarRender&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就有了上一节提到的<strong>树状结构</strong>的基础了！我们可以利用它做这样的事：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 赋值的同时给childRenders赋值</span><br><span class="line">override var selectedDayTime: Long</span><br><span class="line">    set(value) &#123;</span><br><span class="line">        field = value</span><br><span class="line">        childRenders.forEach &#123; it.selectedDayTime = value &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取根ICalendarRender</span><br><span class="line">val rootCalendarRender: ICalendarRender?</span><br><span class="line">    get()  &#123;</span><br><span class="line">        if (parentRender != null) &#123;</span><br><span class="line">            return if (parentRender?.parentRender == null) &#123;</span><br><span class="line">                parentRender</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                parentRender?.rootCalendarRender</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里不妨提前预告一下，这个基于<code>ICalendarRender</code>的日历框架有多重要：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/458e90731b494cf8a1fbfea487d3178d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>可以说内聚度相当高了！</p>
<p>我们可以看到，<code>IScheduleWidget</code>也实现了<code>ICalendarRender</code>接口。后面实现周控件相关的<code>WeekView/WeekDayView/WeekAdapter</code>也是<code>ICalendarRender</code>的子类。我们可以看出，<code>ICalendarRender</code>是抽象的，它的实现不一定是<code>View</code>，而可以是任何对象。</p>
<p>至此，咱们三日&#x2F;日视图就统一到同一套框架下面了，甚至还为整个项目制定了日历框架。</p>
<p>接下来我们就去实现其中的细节吧。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="处理切换三日-日视图"><a href="#处理切换三日-日视图" class="headerlink" title="处理切换三日&#x2F;日视图"></a>处理切换三日&#x2F;日视图</h3><p>首先，三日视图中不显示周控件，而日视图中需要显示，简单啊，在<code>renderRange</code>的<code>setter</code>方法中处理就行了。</p>
<p>我们将<code>renderRange</code>由<code>val</code>常量改成<code>var</code>变量，添加一个<code>setter</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">override var renderRange: IScheduleWidget.RenderRange</span><br><span class="line">    get() = scheduleView.widget.renderRange</span><br><span class="line">    set(value) &#123;</span><br><span class="line">        calendarWidget.renderRange = value</span><br><span class="line">        if (value is IScheduleWidget.RenderRange.ThreeDayRange) &#123;</span><br><span class="line">            weekList.visibility = GONE</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            weekList.visibility = VISIBLE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>小思考</strong>：接口中定义为<code>val</code>常量，为啥实现中可以改为<code>var</code>变量呢？反过来行不行呢？</p>
<p>然后，切换视图后需要刷新UI，自然要在<code>ScheduleWidget</code>中实现了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">override var renderRange: IScheduleWidget.RenderRange by setter(IScheduleWidget.RenderRange.ThreeDayRange) &#123; _, value -&gt;</span><br><span class="line">    render.adapter.notifyModelsChanged()</span><br><span class="line">    scrollTo((selectedDayTime.dDays * dayWidth).roundToInt(), scrollY, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这个<code>by setter</code>是我简单封装了一下<code>Delegates.observable</code>方法，代码整洁一丢丢，当然用普通的<code>setter</code>方法也是可以的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;T&gt; setter(</span><br><span class="line">    default: T,</span><br><span class="line">    crossinline onSet: (old: T, new: T) -&gt; Unit = &#123; old, new -&gt; &#125;</span><br><span class="line">): ReadWriteProperty&lt;Any?, T&gt; = Delegates.observable(default) &#123; _, old, new -&gt;</span><br><span class="line">    onSet(old, new)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>notifyModelsChanged</code>在上一篇里提到过，它的作用和<code>RecyclerView.Adapter</code>中的<code>notifyDataSetChanged</code>差不多，就是为了刷新UI，将一些缓存删掉，这里简单贴一下代码不多展开了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override fun notifyModelsChanged() &#123;</span><br><span class="line">    _taskComponentCache.clear()</span><br><span class="line">    _modelsGroupByDay.clear()</span><br><span class="line">    models.groupBy &#123; it.beginTime.dDays.toInt() &#125;</span><br><span class="line">        .apply &#123; _modelsGroupByDay.putAll(this) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里的<code>scrollTo((selectedDayTime.dDays * dayWidth).roundToInt(), scrollY, 0)</code>是啥意思呢？实际上就是在切换模式后，将代表日期的<code>scrollX</code>基于最新的<code>dayWidth</code>刷新一下，而<code>dayWidth</code>在切换模式后取不同的值即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val dayWidth: Float</span><br><span class="line">    get() = if (ScheduleWidget.isThreeDay) &#123;</span><br><span class="line">        ((screenWidth - clockWidth) / 3).roundToInt().toFloat()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        (screenWidth - clockWidth).roundToInt().toFloat()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="滑动控制"><a href="#滑动控制" class="headerlink" title="滑动控制"></a>滑动控制</h3><p>由于日视图中，左右滑动一次最多只能滑一天，所以需要特殊处理一下，实际上就是修改一下<code>Scroller</code>的行为。我们更新一下在上一篇中提到的<code>autoSnap()</code>方法，根据当前滑动的距离和松手后的速度，共同确定目标<code>scrollX</code>就好了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private fun autoSnap() &#123;</span><br><span class="line">    velocityTracker.computeCurrentVelocity(1000)</span><br><span class="line">    if (scrollHorizontal) &#123;</span><br><span class="line">        // 自适应滑动结束位置</span><br><span class="line">        if (isThreeDay) &#123; // 三日视图，正常滑动距离</span><br><span class="line">            // ...</span><br><span class="line">        &#125; else &#123; // 单日视图，滑动一页</span><br><span class="line">            val velocity = velocityTracker.xVelocity.toInt()</span><br><span class="line">            if (!scroller.isFinished) &#123;</span><br><span class="line">                scroller.abortAnimation()</span><br><span class="line">            &#125;</span><br><span class="line">            val currentDDays = selectedDayTime.dDays.toInt()</span><br><span class="line">            val destDDays = if (velocity &lt; -1000) &#123; // 左滑</span><br><span class="line">                currentDDays + 1</span><br><span class="line">            &#125; else if (velocity &gt; 1000) &#123; // 右滑</span><br><span class="line">                currentDDays - 1</span><br><span class="line">            &#125; else if (scrollX / dayWidth.roundToInt() == currentDDays &amp;&amp; scrollX % dayWidth.roundToInt() &gt; dayWidth / 2) &#123;</span><br><span class="line">                currentDDays + 1</span><br><span class="line">            &#125; else if (scrollX / dayWidth.roundToInt() == currentDDays - 1 &amp;&amp; scrollX % dayWidth.roundToInt() &lt; dayWidth / 2) &#123;</span><br><span class="line">                currentDDays - 1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentDDays</span><br><span class="line">            &#125;</span><br><span class="line">            val dx = (destDDays * dayWidth).roundToInt() - scrollX</span><br><span class="line">            scroller.startScroll(</span><br><span class="line">                scrollX,</span><br><span class="line">                scrollY,</span><br><span class="line">                dx,</span><br><span class="line">                0,</span><br><span class="line">                (abs(dx) - abs(velocity) / 100).coerceAtMost(400).coerceAtLeast(50)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    callOnScrolling(true, true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现周控件"><a href="#实现周控件" class="headerlink" title="实现周控件"></a>实现周控件</h3><p>周控件的实现，就是基于咱们的日历框架，<code>Calendar</code>和自定义控件的简单应用了。</p>
<p>前面有提到，我们是用<code>WeekAdapter</code>-<code>WeekView</code>-<code>WeekDayView</code>这样的层次结构实现的，它们都是实现了<code>ICalendarRender</code>接口的。</p>
<ul>
<li><code>WeekAdapter</code>实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class WeekAdapter(private val recyclerView: RecyclerView) : RecyclerView.Adapter&lt;VH&gt;(),</span><br><span class="line">    ICalendarRender, ICalendarParent &#123;</span><br><span class="line">    override val parentRender: ICalendarRender?</span><br><span class="line">        get() = recyclerView.parent as? ICalendarRender</span><br><span class="line">    override val calendar: Calendar = beginOfDay()</span><br><span class="line">    override var selectedDayTime: Long by setter(nowMillis) &#123; oldTime, time -&gt;</span><br><span class="line">        // 滚动到selectedDayTime对应的那一周的位置</span><br><span class="line">        if (!byDrag &amp;&amp; abs(oldTime.dDays - time.dDays) &lt; 30) &#123;</span><br><span class="line">            recyclerView.smoothScrollToPosition(time.parseWeekIndex())</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            recyclerView.scrollToPosition(time.parseWeekIndex())</span><br><span class="line">        &#125;</span><br><span class="line">        recyclerView.post &#123;</span><br><span class="line">            childRenders.forEach &#123; it.selectedDayTime = time &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override var scheduleModels: List&lt;IScheduleModel&gt; = listOf()</span><br><span class="line">    // 无限滑动，起止时间尽量久远就行</span><br><span class="line">    override val beginTime: Long</span><br><span class="line">        get() = ScheduleConfig.scheduleBeginTime</span><br><span class="line">    override val endTime: Long</span><br><span class="line">        get() = ScheduleConfig.scheduleEndTime</span><br><span class="line"></span><br><span class="line">    override val childRenders: List&lt;ICalendarRender&gt;</span><br><span class="line">        get() = recyclerView.children.filterIsInstance&lt;ICalendarRender&gt;().toList()</span><br><span class="line"></span><br><span class="line">    private val weekCount: Int by lazy &#123;</span><br><span class="line">        val startWeekDay = beginOfDay(beginTime).apply &#123;</span><br><span class="line">            timeInMillis -= (get(Calendar.DAY_OF_WEEK) - Calendar.SUNDAY) * dayMillis</span><br><span class="line">        &#125;.timeInMillis</span><br><span class="line">        val result = ((endTime - startWeekDay) / (7 * dayMillis)).toInt()</span><br><span class="line">        result.apply &#123; Log.i(TAG, &quot;week count = $result&quot;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        recyclerView.run &#123;</span><br><span class="line">            adapter = this@WeekAdapter</span><br><span class="line">            post &#123;</span><br><span class="line">                scrollToPosition(selectedDayTime.parseWeekIndex())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH &#123;</span><br><span class="line">        return VH(parent.context)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getItemCount() = weekCount</span><br><span class="line"></span><br><span class="line">    override fun onBindViewHolder(holder: VH, position: Int) &#123;</span><br><span class="line">        val weekView = holder.itemView as WeekView</span><br><span class="line">        // 为WeekView设置时间</span><br><span class="line">        weekView.calendar.timeInMillis =</span><br><span class="line">            beginOfDay(ScheduleConfig.scheduleBeginTime).timeInMillis + position * 7 * dayMillis</span><br><span class="line">        // WeekView基于自己的起止时间获取日程数据</span><br><span class="line">        weekView.reloadSchedulesFromProvider()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Tips</strong>：<code>reloadSchedulesFromProvider()</code>方法是我们为<code>ICalendarRender</code>接口新增的方法，默认实现为从外部获取<code>scheduleModels</code>以刷新UI。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun reloadSchedulesFromProvider(onReload: () -&gt; Unit = &#123;&#125;) &#123;</span><br><span class="line">    ScheduleConfig.lifecycleScope.launch &#123;</span><br><span class="line">        scheduleModels = withContext(Dispatchers.IO) &#123;</span><br><span class="line">            ScheduleConfig.scheduleModelsProvider.invoke(</span><br><span class="line">                beginTime,</span><br><span class="line">                endTime</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        onReload()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>WeekView</code>实现</li>
</ul>
<p>添加子<code>View</code>的简单的处理方式就是在<code>onAttachedToWindow()</code>方法中，添加7个<code>WeekDayView</code>，并分别给它们设置<code>calendar/selectedDayTime/scheduleModels</code>就行了。然后在<code>onDetachedFromWindow()</code>方法中<code>removeAllViews()</code>。</p>
<p>PS：当然我们也可以做<code>WeekDayView</code>的复用，但因为笔者先写的月视图中的月控件，其中一个月的天数不固定，为了简单就是这样暴力处理了，周控件和月控件结构一样的所以就偷懒也这样处理了。影响不大就有空再优化吧～</p>
<p>咱们也不用再自定义<code>LayoutParams</code>了，直接在<code>onLayout()</code>方法中计算子<code>View</code>的位置就OK了，这里<code>onLayout()</code>中的处理也兼容月视图中的月控件哦（其实就是从月控件中拷过来的）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class WeekView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0</span><br><span class="line">) : ViewGroup(context, attrs, defStyleAttr), ICalendarRender, ICalendarParent &#123;</span><br><span class="line">    override val parentRender: ICalendarRender?</span><br><span class="line">        get() = (parent as? RecyclerView)?.adapter as? ICalendarRender</span><br><span class="line">    override val calendar: Calendar = beginOfDay()</span><br><span class="line">    // 起止时间就是本周的周日零点到周六24点</span><br><span class="line">    override val beginTime: Long</span><br><span class="line">        get() = beginOfDay(calendar.firstDayOfWeekTime).timeInMillis</span><br><span class="line">    override val endTime: Long</span><br><span class="line">        get() = beginOfDay(calendar.lastDayOfWeekTime).timeInMillis + dayMillis</span><br><span class="line">    override var selectedDayTime: Long by setter(-1L) &#123; _, time -&gt;</span><br><span class="line">        childRenders.forEach &#123; it.selectedDayTime = time &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override var scheduleModels: List&lt;IScheduleModel&gt; = listOf()</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            childRenders.forEach &#123; it.getSchedulesFrom(value) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    override val childRenders: List&lt;ICalendarRender&gt;</span><br><span class="line">        get() = children.filterIsInstance&lt;ICalendarRender&gt;().toList()</span><br><span class="line"></span><br><span class="line">    private val dayWidth: Float</span><br><span class="line">        get() = measuredWidth / 7f</span><br><span class="line">    private val dayHeight: Float</span><br><span class="line">        get() = 1f * (measuredHeight - paddingTop) / (childCount / 7)</span><br><span class="line"></span><br><span class="line">    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) &#123;</span><br><span class="line">        for (index in 0 until childCount) &#123;</span><br><span class="line">            val child = getChildAt(index)</span><br><span class="line">            val calendar = (child as ICalendarRender).calendar</span><br><span class="line">            val dDays = calendar.timeInMillis.dDays - beginTime.dDays</span><br><span class="line">            val line = dDays / 7</span><br><span class="line">            val left = dDays % 7 * dayWidth</span><br><span class="line">            val top = line * dayHeight</span><br><span class="line">            val right = left + dayWidth</span><br><span class="line">            val bottom = top + dayHeight</span><br><span class="line">            if (top.isNaN()) continue</span><br><span class="line">            child.layout(</span><br><span class="line">                left.roundToInt(),</span><br><span class="line">                top.roundToInt(),</span><br><span class="line">                right.roundToInt(),</span><br><span class="line">                bottom.roundToInt()</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onAttachedToWindow() &#123;</span><br><span class="line">        super.onAttachedToWindow()</span><br><span class="line">        for (time in beginTime..endTime step dayMillis) &#123;</span><br><span class="line">            WeekDayView(context).let &#123; child -&gt;</span><br><span class="line">                child.calendar.timeInMillis = time</span><br><span class="line">                addView(child)</span><br><span class="line">                child.setOnClickListener &#123;</span><br><span class="line">                    // 点击时通过rootCalendarRender设置顶层日历控件的selectedDayTime</span><br><span class="line">                    if (selectedDayTime.dDays != child.beginTime.dDays) &#123;</span><br><span class="line">                        rootCalendarRender?.selectedDayTime = child.beginTime</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (scheduleModels.any()) &#123;</span><br><span class="line">                    child.getSchedulesFrom(scheduleModels)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDetachedFromWindow() &#123;</span><br><span class="line">        super.onDetachedFromWindow()</span><br><span class="line">        removeAllViews()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Tips</strong>：这里的<code>getSchedulesFrom(scheduleModels)</code>类似<code>reloadSchedulesFromProvider()</code>方法，也是获取数据用的，不同在于它不需要从外部获取，而是从<code>parentRender</code>的<code>scheduleModels</code>中截取就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun getSchedulesFrom(from: List&lt;IScheduleModel&gt;) &#123;</span><br><span class="line">    scheduleModels = from.filter &#123; it.beginTime &gt;= beginTime &amp;&amp; it.endTime &lt;= endTime &#125;</span><br><span class="line">        .sortedBy &#123; it.beginTime &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>WeekDayView</code>实现</li>
</ul>
<p>这是最小控件了，也就不需要实现<code>ICalendarParent</code>接口了，自己根据属性绘制自己就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class WeekDayView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0</span><br><span class="line">) : View(context, attrs, defStyleAttr), ICalendarRender &#123;</span><br><span class="line">    override val parentRender: ICalendarRender</span><br><span class="line">        get() = parent as ICalendarRender</span><br><span class="line">    private val paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">    override val calendar: Calendar = beginOfDay()</span><br><span class="line">    // 起止时间就是当天的零点到24点</span><br><span class="line">    override val beginTime: Long</span><br><span class="line">        get() = calendar.timeInMillis</span><br><span class="line">    override val endTime: Long</span><br><span class="line">        get() = calendar.timeInMillis + dayMillis</span><br><span class="line">    override var selectedDayTime: Long by setter(-1) &#123; _, time -&gt;</span><br><span class="line">        invalidate()</span><br><span class="line">    &#125;</span><br><span class="line">    override var scheduleModels: List&lt;IScheduleModel&gt; = listOf()</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            invalidate()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDraw(canvas: Canvas) &#123;</span><br><span class="line">        super.onDraw(canvas)</span><br><span class="line">        drawDate(canvas)</span><br><span class="line">        // drawTasks(canvas)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun drawDate(canvas: Canvas) &#123;</span><br><span class="line">        // ...省略掉大段的canvas绘制代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="杀割"><a href="#杀割" class="headerlink" title="杀割"></a>杀割</h2><p>本篇涉及的细节部分不多，最重要的就是对<strong>日历框架</strong>的构思，其中包含了笔者一些对<strong>代码结构</strong>的思考和实践。</p>
<p>此时，我也回答了为啥要重复造轮子的问题：因为有了一套日历框架后，项目中各个日历模块是有机的整体，而不是为了实现需求拼凑起来的一堆三方库；并且基于这个框架去开发其他日历视图就事半功倍了。</p>
<p>有问题或建议的朋友，欢迎评论区交流。笔者接下来还会抽时间介绍一下其他两种视图的实现思路和细节，感兴趣的朋友可以关注一下。</p>
<p><a href="https://link.juejin.cn/?target=https://github.com/blackfrogxxoo/ScheduleView/tree/master/widget/src/main/java/me/wxc/widget/schedule" title="https://github.com/blackfrogxxoo/ScheduleView/tree/master/widget/src/main/java/me/wxc/widget/schedule">再贴一下源码</a>，欢迎star和issues。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/02/schedule1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="blackfrog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blackfrog">
      <meta itemprop="description" content="blackfrog的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | blackfrog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/schedule1/" class="post-title-link" itemprop="url">【Android自定义View】高仿飞书日历--三日视图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 22:40:57" itemprop="dateCreated datePublished" datetime="2023-04-02T22:40:57+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-06 17:52:39" itemprop="dateModified" datetime="2023-09-06T17:52:39+08:00">2023-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%87%AA%E5%AE%9A%E4%B9%89View/" itemprop="url" rel="index"><span itemprop="name">自定义View</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer" />


<p>在笔者使用过的日历&#x2F;日程类App中，飞书日程的效果和体验是比较优秀的。但又不能用飞书记录自己的私人日程，只能自己仿写一个了。</p>
<p>飞书上的日程有四种视图：日程、日、三日、月，今天我们先首先要讲的是三日视图（其实日视图和三日视图差不多，只需要处理一下一天的宽度就行了），先上效果图：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25b040840f904838947ea343796c1ea1~tplv-k3u1fbpfcp-watermark.image" alt="三日.gif"></p>
<h2 id="需求确定"><a href="#需求确定" class="headerlink" title="需求确定"></a>需求确定</h2><p>拆解一下这张效果图里的需求：</p>
<ul>
<li>整个控件是一个坐标轴，横轴表示日期（yyyyMMdd），纵轴表示钟点(HHmm)，交点表示具体时间(yyyyMMdd-HHmm)。</li>
<li>坐标内部绘制日程以及当前时间标线。</li>
<li>坐标轴可以上下左右自由滑动，日程和当前时间标线跟随滑动。左右滑动结束后，需要有类似<code>SnapHelper</code>的定位效果。</li>
<li>点击空白区域，可以在相应的时间点创建一个日程，日程可以设置主题、日期、开始&#x2F;结束时间、重复、提醒。</li>
<li>日程可以通过拖曳修改开始时间和持续时间，拖曳修改时间钟点的最小单位是一刻钟(15min)，如果拖曳日程超出控件范围，横、纵坐标自动相应滚动。</li>
</ul>
<h2 id="框架先行"><a href="#框架先行" class="headerlink" title="框架先行"></a>框架先行</h2><p>明确需求后，我们需要构思框架和准备工具了。</p>
<p>首先，时间相关处理，肯定要大量使用时间戳和<code>java.util.Calendar</code>了，并且要做好封装一套工具的准备。</p>
<p>滑动控件，我们首先想到的是<code>RecyclerView</code>、<code>ScrollView</code>之类的。但是坐标需要上下左右自由滑动，而且横坐标还是无限滑动的，甚至日程还可以自由拖曳，作为一个老开发，肯定马上作好避坑的准备了，基于<code>RecyclerView</code>或<code>ScrollView</code>去实现肯定会处处受限制。想要自由发挥，就要把复杂的事情简单化，不外乎<code>meausre</code>、<code>layout</code>、<code>draw</code>，自然而然就想到自定义控件了。至于点击、滑动、长按和拖曳，处理touch事件就好了。</p>
<p>是要覆写<code>View</code>，还是<code>ViewGroup</code>呢，其实已经不重要了。如果覆写<code>View</code>，那么坐标轴、日程等组件，我们就用<code>canvas</code>绘制；如果覆写<code>ViewGroup</code>，我们可能要把各组件的测量和绘制交给子View来处理。既然我们想要不受限制，那就自由到底，开撸！</p>
<h3 id="绘制框架"><a href="#绘制框架" class="headerlink" title="绘制框架"></a>绘制框架</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ScheduleView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0</span><br><span class="line">) : View(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    private val paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line"></span><br><span class="line">    override fun onDraw(canvas: Canvas) &#123;</span><br><span class="line">        super.onDraw(canvas)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onTouchEvent(event: MotionEvent): Boolean &#123;</span><br><span class="line">        return onTouchEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们定义了一张白纸，一支笔。</p>
<p>有的同学可能已经迫不及待地在<code>onDraw</code>方法下写下如下方法了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun onDraw(canvas: Canvas) &#123;</span><br><span class="line">    // 绘制X轴坐标</span><br><span class="line">    drawDateLine(canvas)</span><br><span class="line">    // 绘制Y轴坐标</span><br><span class="line">    drawClockLine(canvas)</span><br><span class="line">    // 绘制日程</span><br><span class="line">    drawSchedules(canvas)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请先等一等！</p>
<p>数据驱动UI，是作为画UI程序页的基本思想。只要反复默念“<strong>数据驱动UI</strong>”一百次，满屏幕都变成了数据了。控件里的组件长着同样的骨骼：beginTime - endTime。于是，马上写下我们的基本接口，它也将是整个业务的基本抽象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IScheduleModel</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> beginTime: <span class="built_in">Long</span></span><br><span class="line">    <span class="keyword">val</span> endTime: <span class="built_in">Long</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑一下，每个可绘制的组件，都是（或有）一个<code>IScheduleModel</code>，我们可以假想组件就是一个子<code>View</code>，但是又不是真正的<code>View</code>。为了实现与数据分离，先抽象一下“组件”这个家伙好了。我们可以直接模仿<code>View</code>的api，为了让它有一点不一样，位置和大小我们用一个<code>RectF</code>来表示，因为它既可以描述位置，也可以描述尺寸。更新rect的位置时，我们需要锚定当前的位置，那就定义一个带锚参数的<code>updateDrawingRect</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IScheduleComponent&lt;T : IScheduleModel&gt; &#123;</span><br><span class="line">    val model: T</span><br><span class="line">    val drawingRect: RectF</span><br><span class="line">    fun updateDrawingRect(anchorPoint: Point)</span><br><span class="line">    fun onDraw(canvas: Canvas, paint: Paint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我们的<code>onDraw</code>中的实现就跟着被抽象了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private val scrollPosition = Point()</span><br><span class="line">override fun onDraw(canvas: Canvas) &#123;</span><br><span class="line">    visibleComponents.forEach &#123;</span><br><span class="line">        it.updateDrawingRect(scrollPosition)</span><br><span class="line">        it.onDraw(canvas, paint)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的意思是，在每次触发<code>onDraw</code>方法时，都遍历可见的<code>IScheduleComponent</code>，更新<code>drawingRect</code>，再绘制它就好了。这就是整个绘制（包括测量和定位）过程的基本框架了，每个component的细节可以分别实现了。</p>
<h3 id="滑动框架"><a href="#滑动框架" class="headerlink" title="滑动框架"></a>滑动框架</h3><p>有的同学可能已经迫不及待地开始写绘制框架的具体实现了。</p>
<p>请先等一等。</p>
<p>我们还有滑动相关的框架没有写呢。既要上下左右自由滑动，又要snap效果，简直比<code>RecyclerView</code>还要复杂啊。<code>RecyclerView</code>都要定义一个<code>LayoutManager</code>来管理滑动和布局，我们也有理由把滑动逻辑抽象出来。我们定义一个<code>IScheduleWidget</code>，用以管理滑动事宜。相应的，<code>ScheduleView</code>负责绘制，也可以抽象成一个<code>IScheduleRender</code>，用以更新component位置的<code>scrollPosition</code>，就可以抽象于此。暂且让它们俩双向依赖吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface IScheduleWidget &#123;</span><br><span class="line">    val render: IScheduleRender</span><br><span class="line">    fun onTouchEvent(motionEvent: MotionEvent): Boolean</span><br><span class="line">    fun onScroll(x: Int, y: Int)</span><br><span class="line">    fun scrollTo(x: Int, y: Int, duration: Int = 250)</span><br><span class="line">    fun isScrolling(): Boolean</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">interface IScheduleRender &#123;</span><br><span class="line">    var widget: IScheduleWidget</span><br><span class="line">    val scrollPosition: Point</span><br><span class="line">    fun render(x: Int, y: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是，ScheduleView就成了这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class ScheduleView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0</span><br><span class="line">) : View(context, attrs, defStyleAttr), IScheduleRender &#123;</span><br><span class="line">    private val paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">    override lateinit var widget: IScheduleWidget</span><br><span class="line">    override val scrollPosition: Point = Point()</span><br><span class="line"></span><br><span class="line">    override fun render(x: Int, y: Int) &#123;</span><br><span class="line">        scrollPosition.x = x</span><br><span class="line">        scrollPosition.y = y</span><br><span class="line">        invalidate()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onDraw(canvas: Canvas) &#123;</span><br><span class="line">        visibleComponents.forEach &#123;</span><br><span class="line">            it.updateDrawingRect(scrollPosition)</span><br><span class="line">            it.onDraw(canvas, paint)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onTouchEvent(event: MotionEvent): Boolean &#123;</span><br><span class="line">        return widget.onTouchEvent(event)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后实现<code>IScheduleWidget</code>，这样整个绘制、滑动框架就定义完成了。左右滑动控件时，都会自动更新坐标的位置，并触发<code>ScheduleView</code>下的各components绘制自己。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ScheduleWidget(override val render: IScheduleRender) : IScheduleWidget &#123;</span><br><span class="line">    private var scrollX: Int = 0 // 0代表今天</span><br><span class="line">    private var scrollY: Int = 0 // 0代表零点</span><br><span class="line">    override fun onTouchEvent(motionEvent: MotionEvent): Boolean &#123;</span><br><span class="line">        // TODO 处理手势，计算scroolX/Y</span><br><span class="line">        // scrollX = handle(motionEvent)</span><br><span class="line">        // scrollY = handle(motionEvent)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onScroll(x: Int, y: Int) &#123;</span><br><span class="line">        // 需要注意的是，滑动距离和坐标对应的x、y是相反的</span><br><span class="line">        render.render(-x, -y)</span><br><span class="line">    &#125;</span><br><span class="line">    override fun scrollTo(x: Int, y: Int) &#123;</span><br><span class="line">        // TODO 对外暴露的scroll方法</span><br><span class="line">        // scrollX = handle(x)</span><br><span class="line">        // scrollY = handle(y)</span><br><span class="line">    &#125;</span><br><span class="line">    override fun isScrolling(): Boolean = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，需求中需要拖曳日程，component就像一个<code>View</code>，当然也可以处理了touch事件了，复制一个<code>onTouchEvent</code>方法好了。由于只有拖曳日程时需要单独处理，我们给它一个空实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IScheduleComponent&lt;T : IScheduleModel&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    fun onTouchEvent(ev: TouchEvent): Boolean = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此框架已经完成了。接下来，我们终于可以开始写实现部分了。由于比较枯燥，我们只针对一些关键实现做一部分讲解，详细代码请<a target="_blank" rel="noopener" href="https://github.com/blackfrogxxoo/ScheduleView/tree/master/widget/src/main/java/me/wxc/widget/schedule">参阅源码</a>。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="怎样计算component位置"><a href="#怎样计算component位置" class="headerlink" title="怎样计算component位置"></a>怎样计算component位置</h3><p>时间戳和坐标中的位置是一一对应的，上公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = dayWidth * (days - todayDays)</span><br><span class="line">y = dayHeight * hours / 24</span><br></pre></td></tr></table></figure>

<p>今天零点的x和y就是初始值，任何组件都可以计算相对于今天零点的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun IScheduleModel.originRect(): RectF &#123;</span><br><span class="line">    // x轴： 与当天的间隔天数 * 一天的宽度</span><br><span class="line">    // y轴： 当前分钟数 / 一天的分钟数 * 一天的高度</span><br><span class="line">    val dDays = beginTime.dDays</span><br><span class="line">    val left = clockWidth + dDays * dayWidth</span><br><span class="line">    val right = left + dayWidth</span><br><span class="line">    val zeroClockTime = beginOfDay(beginTime).timeInMillis</span><br><span class="line">    val top = dateLineHeight + dayHeight * (beginTime - zeroClockTime) / dayMillis</span><br><span class="line">    val bottom = dateLineHeight + dayHeight * (endTime - zeroClockTime) / dayMillis</span><br><span class="line">    return RectF(left, top, right, bottom)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun IScheduleComponent&lt;*&gt;.originRect(): RectF = model.originRect()</span><br></pre></td></tr></table></figure>
<p>当前时间标线可以跟随坐标上下左右滑动，所以<code>drawingRect</code>(相对位置)是由<code>originRect</code>（绝对位置）和<code>anchorPoint</code>(滑动距离)共同决定的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// NowLineComponent</span><br><span class="line">override fun updateDrawingRect(anchorPoint: Point) &#123;</span><br><span class="line">    drawingRect.left = originRect.left + anchorPoint.x</span><br><span class="line">    drawingRect.right = originRect.right + anchorPoint.x</span><br><span class="line">    drawingRect.top = originRect.top + anchorPoint.y</span><br><span class="line">    drawingRect.bottom = originRect.bottom + anchorPoint.y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而时刻表(y坐标轴)不跟随左右滑动，就是不需要处理x轴。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ClockLineComponent</span><br><span class="line">override fun updateDrawingRect(anchorPoint: Point) &#123;</span><br><span class="line">    drawingRect.top = originRect.top + anchorPoint.y</span><br><span class="line">    drawingRect.bottom = originRect.bottom + anchorPoint.y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="怎样维护visibleComponents"><a href="#怎样维护visibleComponents" class="headerlink" title="怎样维护visibleComponents"></a>怎样维护visibleComponents</h3><p>前面的框架代码中，我们在<code>ScheduleView</code>的<code>onDraw</code>方法中，遍历了<code>visibleComponents</code>。那么，这个<code>visibleComponents</code>怎么来的呢？总不能有一万个日程，都要生成一万个component来遍历和绘制吧。这里又可以参考<code>RecyclerView</code>了，我们也抽象一个adapter接口出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IScheduleRenderAdapter &#123;</span><br><span class="line">    var models: MutableList&lt;IScheduleModel&gt;</span><br><span class="line">    val visibleComponents: List&lt;IScheduleComponent&lt;*&gt;&gt;</span><br><span class="line">    fun onCreateComponent(model: IScheduleModel): IScheduleComponent&lt;*&gt;?</span><br><span class="line">    fun notifyModelsChanged()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且，让<code>IScheduleRender</code>持有一个<code>IScheduleRenderAdapter</code>，我们再通过实现<code>visibleComponents</code>和<code>onCreateComponent</code>方法来实现具体逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IScheduleRender &#123;</span><br><span class="line">    ...</span><br><span class="line">    val adapter: IScheduleRenderAdapter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的，ScheduleView中也要有相应实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class ScheduleView @JvmOverloads constructor(</span><br><span class="line">    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0</span><br><span class="line">) : View(context, attrs, defStyleAttr), IScheduleRender &#123;</span><br><span class="line">    private val paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">    override lateinit var widget: IScheduleWidget</span><br><span class="line">    override val scrollPosition: Point = Point()</span><br><span class="line">    override val adapter: IScheduleRenderAdapter = ScheduleAdapter()</span><br><span class="line">    </span><br><span class="line">    override fun render(x: Int, y: Int) &#123;</span><br><span class="line">        scrollPosition.x = x</span><br><span class="line">        scrollPosition.y = y</span><br><span class="line">        invalidate()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onDraw(canvas: Canvas) &#123;</span><br><span class="line">        adapter.visibleComponents.forEach &#123;</span><br><span class="line">            it.updateDrawingRect(scrollPosition)</span><br><span class="line">            it.onDraw(canvas, paint)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onTouchEvent(event: MotionEvent): Boolean &#123;</span><br><span class="line">        return widget.onTouchEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class ScheduleAdapter : IScheduleRenderAdapter &#123;</span><br><span class="line">        // ...在adapter中处理model与component的转换过程，涉及分组、缓存和复用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="怎样实现坐标滑动"><a href="#怎样实现坐标滑动" class="headerlink" title="怎样实现坐标滑动"></a>怎样实现坐标滑动</h3><p>简单来说，就是<code>GestureDetector</code>、<code>VelocityTracker</code>、<code>Scroller</code>这三个工具的应用了。</p>
<p>在<code>ScheduleWidget</code>的<code>onTouchEvent</code>中需要同时处理坐标和日程的拖曳，所以大致是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun onTouchEvent(motionEvent: MotionEvent): Boolean &#123;</span><br><span class="line">    // 为了计算松手后的滑动速度，在这里把motionEvent添加到velocityTracker中</span><br><span class="line">    velocityTracker.addMovement(motionEvent)</span><br><span class="line">    // 日程拖曳相关</span><br><span class="line">    val downOnCreate = createTaskComponent?.onTouchEvent(motionEvent) ?: false</span><br><span class="line">    // 处理松手后的位置snap</span><br><span class="line">    if (motionEvent.action == MotionEvent.ACTION_UP) autoSnap()</span><br><span class="line">    // 坐标滑动相关处理交给guestureDetector</span><br><span class="line">    return downOnCreate || gestureDetector.onTouchEvent(motionEvent)</span><br></pre></td></tr></table></figure>
<p>而在<code>gestureDetector</code>中，我们覆写<code>onDown</code>和<code>onScroll</code>方法，以处理上下左右的滑动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private var justDown = false</span><br><span class="line">override fun onDown(e: MotionEvent): Boolean &#123;</span><br><span class="line">    justDown = true</span><br><span class="line">    if (!scroller.isFinished) &#123;</span><br><span class="line">        scroller.abortAnimation()</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line">override fun onScroll(</span><br><span class="line">    e1: MotionEvent,</span><br><span class="line">    e2: MotionEvent,</span><br><span class="line">    distanceX: Float,</span><br><span class="line">    distanceY: Float</span><br><span class="line">): Boolean &#123;</span><br><span class="line">    if (justDown) &#123;</span><br><span class="line">        scrollHorizontal = abs(distanceX) &gt; abs(distanceY)</span><br><span class="line">    &#125;</span><br><span class="line">    if (scrollHorizontal) &#123;</span><br><span class="line">        scrollX += distanceX.toInt()</span><br><span class="line">        scrollX = scrollX.coerceAtMost(MAX_SCROLL_X).coerceAtLeast(MIN_SCROLL_X)</span><br><span class="line">        onScroll(scrollX, scrollY)</span><br><span class="line">    &#125; else if (!downOnDateLine) &#123;</span><br><span class="line">        scrollY += distanceY.toInt()</span><br><span class="line">        scrollY = scrollY.coerceAtMost(MAX_SCROLL_Y).coerceAtLeast(MIN_SCROLL_Y)</span><br><span class="line">        onScroll(scrollX, scrollY)</span><br><span class="line">    &#125;</span><br><span class="line">    justDown = false</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于自动定位的<code>autoSnap</code>方法，依赖<code>Scroller</code>的<code>fling</code>和<code>setFinalX</code>方法，大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private fun autoSnap() &#123;</span><br><span class="line">    // 自适应左右滑动结束位置</span><br><span class="line">    velocityTracker.computeCurrentVelocity(1000)</span><br><span class="line">    if (scrollHorizontal) &#123;</span><br><span class="line">        // 只需要计算水平方向</span><br><span class="line">        scroller.fling(</span><br><span class="line">            scrollX,</span><br><span class="line">            0,</span><br><span class="line">            -velocityTracker.xVelocity.toInt(),</span><br><span class="line">            0,</span><br><span class="line">            Int.MIN_VALUE,</span><br><span class="line">            Int.MAX_VALUE,</span><br><span class="line">            0,</span><br><span class="line">            0</span><br><span class="line">        )</span><br><span class="line">        // 天数取整后乘以dayWidth</span><br><span class="line">        scroller.finalX =</span><br><span class="line">            ((scroller.finalX / dayWidth).roundToInt() * dayWidth).roundToInt()</span><br><span class="line">                .coerceAtMost(MAX_SCROLL_X).coerceAtLeast(MIN_SCROLL_X)</span><br><span class="line">    &#125;</span><br><span class="line">    callOnScrolling(true, true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="杀割"><a href="#杀割" class="headerlink" title="杀割"></a>杀割</h2><p>除此之外，还有不少实现细节，包括：日程的拖曳，批量创建&#x2F;编辑，添加日历提醒，处理时间冲突的日程等，篇幅原因也就不展开介绍了，有问题评论区交流。</p>
<p>笔者接下来还会抽时间介绍一下其他三种视图的实现思路和细节，感兴趣的朋友可以关注一下。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/blackfrogxxoo/ScheduleView/tree/master/widget/src/main/java/me/wxc/widget/schedule">再贴一下源码</a>，欢迎star和issues。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">blackfrog</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
